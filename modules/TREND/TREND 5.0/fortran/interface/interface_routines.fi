    !*************************************************************************************
    !				TREND Version 5.0
    !		   Thermodynamic Reference & Engineering Data
    !
    !- software for the calculation of thermodynamic and other properties -
    !
    !Copyright (C) 2020,  Prof. Dr.-Ing. R.Span
    !                     Lehrstuhl fuer Thermodynamik
    !                     Ruhr-Universitaet Bochum
    !                     Universitaetsstr. 150
    !                     D-44892 Bochum
    !
    !Cite as: Span, R.; Beckmüller, R.; Hielscher, S.; Jäger, A.; Mickoleit, E.;
    !          Neumann, T.; Pohl S. M.; Semrau, B.; Thol, M. (2020):
    !          TREND. Thermodynamic Reference and Engineering Data 5.0.
    !          Lehrstuhl für Thermodynamik, Ruhr-Universität Bochum.

    !
    !This program is free software: you can redistribute it and/or modify
    !it under the terms of the GNU General Public License as published by
    !the Free Software Foundation, either version 3 of the License, or
    !(at your option) any later version.
    !
    !This program is distributed in the hope that it will be useful,
    !but WITHOUT ANY WARRANTY; without even the implied warranty of
    !MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    !GNU General Public License for more details.
    !
    !You should have received a copy of the GNU General Public License
    !along with this program.  If not, see < http://www.gnu.org/licenses/ >.
    !
    !*************************************************************************************


    !##########################################################################################
#define STRINGIFY2(n)    #n
#define STRINGIFY(n)    STRINGIFY2(n)

#if defined(MAKE_STDCALL)
#include "STDCALL.fi"

#elif defined(MAKE_CDECL)
#include "CDecl.fi"

#elif defined(MAKE_MATLAB)
#include "MATLAB.fi"

#elif defined(MAKE_SAFEARR)
#include "Safearrays_STDCALL.fi"

#endif
    !##########################################################################################
    !#########################################################################################
    !module for calls from .net languages
    !#########################################################################################
#IF DEFINED(MAKE_SAFEARR)

    module safearrays


    contains
    subroutine safearray_to_chararray(save_char_array, n, FORTRAN_char_vektor, FORTRAN_char_array)

    use ifcom

    implicit none

    integer(int_ptr_kind()), intent(inout) :: save_char_array  !Pointer to a SafeArray structure
    integer, intent(in) :: n
    character*n,dimension(:,:), allocatable, optional :: FORTRAN_char_array
    character*n, dimension(:), allocatable, optional :: FORTRAN_char_vektor

    integer, parameter :: LONG_ENOUGH_BUFFER = 2048 ! Assume we won't get a string longer than this
    character(LEN=LONG_ENOUGH_BUFFER)  mystring  ! Fortran string converted to/from BSTR
    integer(int_ptr_kind()) :: BSTRptr  ! Receives a pointer to a BSTR
    type bounds_type
        integer lb  ! Lower Bound
        integer ub  ! Upper Bound
    end type bounds_type
    integer nbounds  ! Number of bounds
    type(bounds_type), allocatable :: bounds(:)
    integer, allocatable :: indexes(:)  ! Array to hold current element indexes
    integer :: i, k, iRes, length, row, col
    ! First, we'll get the bounds of the array. This code makes no assumptions about the number of
    ! dimensions.
    !

    nbounds = SafeArrayGetDim (save_char_array)



    allocate (bounds(nbounds), indexes(nbounds))
    do i=1,nbounds
        ires = SafeArrayGetLbound (save_char_array, i, bounds(i)%lb)
        ires = SafeArrayGetUbound (save_char_array, i, bounds(i)%ub)
    end do

    indexes = bounds%lb  ! Initialize to all lower bounds
    row = 0
    col = 0
    readloop: do

        ires = SafeArrayGetElement (save_char_array, indexes(1), loc(BSTRPtr))
        length = ConvertBSTRToString (BSTRPtr, mystring)
        call SysFreeString(BSTRPtr)
        if (nbounds == 1) then
            FORTRAN_char_vektor(indexes(1)+1) = mystring(1:length)
        else
            FORTRAN_char_array(indexes(1)+1,indexes(2)+1) = mystring(1:length)
        end if

        ! Determine what the next element is.  We increment the last index,
        ! and if it is greater than the upper bound, reset it to the lower bound and
        ! repeat for the next lower index.  If we run out of indexes, we're done.
        do i = nbounds, 1, -1
            indexes(i) = indexes(i) + 1
            if (indexes(i) <= bounds(i)%ub) exit
            indexes(i) = bounds(i)%lb
            if (i == 1) exit readloop
        end do
    end do readloop
    deallocate (bounds)
    deallocate (indexes)

    end subroutine

    subroutine chararray_to_safearray(save_char_array, n, FORTRAN_char_vektor, FORTRAN_char_array)

    use ifcom

    implicit none

    integer(int_ptr_kind()), intent(inout) :: save_char_array  !Pointer to a SafeArray structure
    integer, intent(in) :: n
    character*n,dimension(:,:), allocatable, optional :: FORTRAN_char_array
    character*n, dimension(:), allocatable, optional :: FORTRAN_char_vektor

    integer, parameter :: LONG_ENOUGH_BUFFER = 2048 ! Assume we won't get a string longer than this
    character(LEN=LONG_ENOUGH_BUFFER)  mystring  ! Fortran string converted to/from BSTR
    integer(int_ptr_kind()) :: BSTRptr  ! Receives a pointer to a BSTR
    type bounds_type
        integer lb  ! Lower Bound
        integer ub  ! Upper Bound
    end type bounds_type
    integer nbounds  ! Number of bounds
    type(bounds_type), allocatable :: bounds(:)
    integer, allocatable :: indexes(:)  ! Array to hold current element indexes
    integer :: i, k, iRes, length
    ! First, we'll get the bounds of the array. This code makes no assumptions about the number of
    ! dimensions.
    !

    nbounds = SafeArrayGetDim (save_char_array)



    allocate (bounds(nbounds), indexes(nbounds))
    do i=1,nbounds
        ires = SafeArrayGetLbound (save_char_array, i, bounds(i)%lb)
        ires = SafeArrayGetUbound (save_char_array, i, bounds(i)%ub)
    end do

    indexes = bounds%lb  ! Initialize to all lower bounds

    readloop: do
        if (nbounds == 1) then
            mystring = FORTRAN_char_vektor(indexes(1)+1)
        else
            mystring = FORTRAN_char_array(indexes(1)+1,indexes(2)+1)
        end if
        ! Convert it back to a BSTR
        BSTRptr = ConvertStringToBSTR (trim(mystring))

        ! Write it back to the array
        ires = SafeArrayPutElement (save_char_array, indexes(1), BSTRptr)
        call SysFreeString (BSTRPtr)  ! Free our copy

        ! Determine what the next element is.  We increment the last index,
        ! and if it is greater than the upper bound, reset it to the lower bound and
        ! repeat for the next lower index.  If we run out of indexes, we're done.
        do i = nbounds, 1, -1
            indexes(i) = indexes(i) + 1
            if (indexes(i) <= bounds(i)%ub) exit
            indexes(i) = bounds(i)%lb
            if (i == 1) exit readloop
        end do
    end do readloop
    deallocate (bounds)
    deallocate (indexes)

    end subroutine

    end module safearrays
#ENDIF



    module MAKE_MODULE_NAME(interface_routines)

    use, intrinsic :: iso_c_binding
    use module_all_types
    use interface_support_module
    use controlling
    use calc_functions
    use calc_func_ptr
    use phasenv_pure_module
    use phasenv_vbased_module
    use ancillary_equations_mix_module
    use ptx_diag_module
    use dryice_module
    use waterice_module
    use uncty_module
    use interface_helper
    use unit_convertion
    use trend_calc_m
    !use gibbsderivs_module

#IF DEFINED (MAKE_SAFEARR)
    use ifcom
    use safearrays
#ENDIF


    contains



    subroutine uppertolower_char_list(char_list_in)
    character(*),dimension(:) :: char_list_in
    integer :: i

    do i=1,size(char_list_in)
        call uppertolower_char(char_list_in(i),len(char_list_in(i)))
    end do

    end subroutine uppertolower_char_list



    ! END OF HELPER FUNCTIONS ---------------------------------------------------------------------------------------------------------------------------------

    !#########################################################################################
    !##################################################################
    !TREND_EOS function calculates a thermophysical property depending on the input
    !calctype       character(12)           specification of the property that has to be calculated possible calculations are: see if-block below
    !input          character(12)           specifies the given state point where the property has to be calculated, possible inputs are:
    !                                       TP (prop1 is temperature, prop2 is pressure)
    !                                       TD (prop1 is temperature, prop2 is density)
    !                                       PS(prop1 is pressure, prop2 is entropy)
    !                                       PH (prop1 is pressure, prop2 is enthalpy)
    !                                       TLIQ (prop1 is temperature on bubble line, prop2 is ignored)
    !                                       TVAP(prop1 is temperature on dew line, prop2 is ignored)
    !                                       PLIQ (prop1 is pressure on bubble line, prop2 is ignored)
    !                                       PVAP (prop1 is pressure on dew line, prop2 is ignored)
    !prop1, prop2   double                  values for state point depending on input
    !fluids         character(30),dim(30)   fluid/mixture calculations are conducted with
    !moles          double,dim(30)          composition  calculations are conducted with
    !EOS_indicator  integer,dim(30)         equation of state indicator calculations are conducted with
    !                                       1: Helmholtz
    !                                       2: SRK
    !                                       3: PR
    !                                       4: LKP
    !                                       5: Generalized EOS (51: based on Alexandrov 52: based on Span/Wagner 53: based on Sun/Ely)
    !                                       6: PCSAFT
    !                                       7: AGA8
    !                                       8: RKM
    !                                       9: COSTALD
    !MIX_indicator  integer                 indicator for mixing rule
    !                                       1:      Helmholtz default,
    !                                       110:    All components are mixed according to the linear mixing rule
    !                                       111:    check if binary mix files are available, if not use linear mixing rule
    !                                       120:    All components are mixed according to the Lorentz-Berthelot mixing rule.
    !                                       121:    check if binary mix files are available, if not use Lorentz-Berthelot mixing rule.
    !                                       2:      mixing rule according to SRK model
    !                                       3:      mixing rule according to PR model
    !                                       4:      mixing rule according to LKP model
    !                                       5:      mixing rule according to Gen EOS model
    !                                       6:      mixing rule according to PC SAFT model
    !                                       7:      mixing rule according to AGA8 model
    !                                       8:      mixing rule according to RKM model
    !                                       9:      mixing rule according to COSTALD model
    !path           chracter(255)           main directory of TREND
    !unitdefintion  character(20)           choose molar/specific input and output
    !gl_handle         integer(c_intptr_t)     memory adress of gl type
    !##################################################################
    double precision function MAKE_FUNC_NAME(TREND_EOS) (calctype_arg, input_arg, prop1_arg, prop2_arg, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, unitdefinition_arg,errorflag, gl_handle) result(TREND_EOS_RESULT)
    !##########################################################################################
#define LOCAL_FUNC_NAME() TREND_EOS
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

    MAKE_ARG_CHAR(12), intent(inout) :: calctype_arg
    MAKE_ARG_CHAR(12), intent(inout) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg



    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    !Define input variables
    character (12) :: input, unit
    character(12) :: calctype
    double precision :: prop1, prop2, prop1_arg, prop2_arg, wm_mix
    character (30), dimension(30) :: fluids
    double precision, dimension (30) :: moles
    character (255) :: path
    integer, dimension (30) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin
    character (1) :: propID
    integer :: calctype_internal
    integer :: ididit, errorflag
    character (255) :: errorcodes
    character (20) :: unitdefinition
    logical :: fluid_present
    integer :: i,nr_fld
    integer :: IS_ERROR

    !-------------------------------------------------------------------------------------------------------------------------------------------------

    !##########################################################################################
    !Preprocessor definition start

    STRING_TO_F(calctype, 12)
    STRING_TO_F(input, 12)
#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(unitdefinition,20)

    !Preprocessor definition end
    !##########################################################################################
    TREND_EOS_RESULT = 0.d0
    !Reset internal calctype
    calctype_internal = 0
    errorflag = 0

    prop1 = prop1_arg
    prop2 = prop2_arg

    ! Set all input chars to lower chars
    !call uppertolower_char_list((/unitdefinition,calctype,input/))
    call uppertolower_char(unitdefinition,len(unitdefinition))
    call uppertolower_char(calctype,len(calctype))
    call uppertolower_char(input,len(input))

    ! Get the unitin form unitdefinition
    unitin = get_unitin(unitdefinition)
    if(unitin < 0) then
        TREND_EOS_RESULT = unitin
        errorflag = unitin
        return
    end if

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)

    !default settings for all calculations:
    gl%calc_ref = .false.  ! calculate reference state
    gl%transport = 0       ! needed to check the range of validity for transport properties; 1 for transport properties, 0 for every other property
    gl%VLE_needed = .false.
    gl%converttype = 0
    gl%vir = .false.

    !Check for errors:
    if(errorflag.ne.0) then
        TREND_EOS_RESULT = errorflag
        return
    end if


    !***********************************************************************************************************************
    if(trim(calctype) .eq. "t") then		![K]
        !Check if input includes T
        propID = "t"
        Call check_triv_input(gl,input, propID, ididit)
        if (ididit == 1) then
            if (prop1 .lt. 1.d-12) then     !temperature input less than 0 --> not defined
                TREND_EOS_RESULT = -9911.d0
            else
                TREND_EOS_RESULT = prop1
            end if
            return
        else if (ididit == 2) then
            if (prop2 .lt. 1.d-12) then     !temperature input less than 0 --> not defined
                TREND_EOS_RESULT = -9911.d0
            else
                TREND_EOS_RESULT = prop2
            end if
            return
        end if
        calctype_internal = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d") then		![mol/m^3]
        !Check if input includes T
        propID = "d"
        Call check_triv_input(gl,input, propID, ididit)
        if (ididit == 1) then
            if (prop1 .lt. 1.d-12) then     !density input less than 0 --> not defined
                TREND_EOS_RESULT = -9922.d0
            else
                TREND_EOS_RESULT = prop1
            end if
            return
        else if (ididit == 2) then
            if (prop2 .lt. 1.d-12) then     !density input less than 0 --> not defined
                TREND_EOS_RESULT = -9922.d0
            else
                TREND_EOS_RESULT = prop2
            end if
            return
        end if
        calctype_internal = 2
        gl%converttype = 2
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "p") then		![MPa]
        !Check if input includes T
        propID = "p"
        Call check_triv_input(gl,input, propID, ididit)
        if (ididit == 1) then
            if (prop1 .lt. 1.d-12) then     !pressure input less than 0 --> not defined
                TREND_EOS_RESULT = -9933.d0
            else
                TREND_EOS_RESULT = prop1
            end if
            return
        else if (ididit == 2) then
            if (prop2 .lt. 1.d-12) then     !pressure input less than 0 --> not defined
                TREND_EOS_RESULT = -9933.d0
            else
                TREND_EOS_RESULT = prop2
            end if
            return
        end if
        calctype_internal = 3
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "u") then		![J/mol]
        gl%calc_ref = .true.  ! calculate reference state
        calctype_internal = 4
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "h") then		![J/mol]
        !Check if input includes T
        propID = "h"
        Call check_triv_input(gl,input, propID, ididit)
        if (ididit == 1) then
            TREND_EOS_RESULT = prop1
            return
        else if (ididit == 2) then
            TREND_EOS_RESULT = prop2
            return
        end if
        gl%calc_ref = .true.  ! calculate reference state
        calctype_internal = 5
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "s") then		![J/(mol K)]
        !Check if input includes T
        propID = "s"
        Call check_triv_input(gl,input, propID, ididit)
        if (ididit == 1) then
            TREND_EOS_RESULT = prop1
            return
        else if (ididit == 2) then
            TREND_EOS_RESULT = prop2
            return
        end if
        gl%calc_ref = .true.  ! calculate reference state
        calctype_internal = 6
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "g") then		![J/mol]
        gl%calc_ref = .true.  ! calculate reference state
        calctype_internal = 7
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a") then		![J/mol]
        gl%calc_ref = .true.  ! calculate reference state
        calctype_internal = 8
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "cp") then		![J/(mol K)]
        calctype_internal = 9
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "cv") then		![J/(mol K)]
        calctype_internal = 10
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "ws") then		![m/s]
        calctype_internal = 11
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "bvir") then		![m^3/mol]
        calctype_internal = 12
        gl%converttype = 3
        gl%vir = .true.
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "cvir") then		![m^6/mol^2]
        calctype_internal = 13
        gl%converttype = 4
        gl%vir = .true.
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "cp0") then      ![J/(mol K)]
        calctype_internal = 14
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "q") then		![mol/mol]
        calctype_internal = 15
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "z") then		![-]
        calctype_internal = 16
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "pnum") then		![MPa]
        calctype_internal = 17
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "wsnum") then	![m/s]
        calctype_internal = 18
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a00") then		![-]
        calctype_internal = 19
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a01") then		![-]
        calctype_internal = 20
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a02") then		![-]
        calctype_internal = 21
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a03") then		![-]
        calctype_internal = 22
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a10") then		![-]
        calctype_internal = 23
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a11") then		![-]
        calctype_internal = 24
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a12") then		![-]
        calctype_internal = 25
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a20") then		![-]
        calctype_internal = 26
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a21") then		![-]
        calctype_internal = 27
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "a30") then		![-]
        calctype_internal = 28
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "ur") then		![J/mol]
        calctype_internal = 29
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "hr") then		![J/mol]
        calctype_internal = 30
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "sr") then		![J/(mol K)]
        calctype_internal = 31
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "cvr") then		![J/(mol K)]
        calctype_internal = 32
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "cpotr") then		![J/mol]
        calctype_internal = 33
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "gruen") then		![-]
        calctype_internal = 34
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "pip") then		![-]
        calctype_internal = 35
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "de") then		![-]
        gl%transport = 3    !if transport=3, range of validity of the dielectricity EOS will be evaluated (if no "&" occurs in the input code)
        calctype_internal = 36
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "st") then		![mN/m]
        calctype_internal = 37
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "eta") then		![nu Pa /s]
        gl%transport = 1       !if transport=1, range of validity of the viscosity EOS will be evaluated (if no "&" occurs in the input code)
        calctype_internal = 38
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "tcx") then		![W/(m K)]
        gl%transport = 2       !if transport=2, range of validity of the thermal conductivity EOS will be evaluated (if no "&" occurs in the input code)
        calctype_internal = 39
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "vexp") then     ![1 / K]
        calctype_internal = 40
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dvir") then		![m^9/mol^4]
        calctype_internal = 41
        gl%converttype = 5
        gl%vir = .true.
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "riem") then         ![-]
        calctype_internal = 42
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "compt") then		![1/MPa]
        calctype_internal = 43
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "comps") then		![1/MPa]
        calctype_internal = 44
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "throt") then		![m^3/mol]
        calctype_internal = 45
        gl%converttype = 3
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "exps") then         ![-]
        calctype_internal = 46
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "expt") then         ![-]
        calctype_internal = 47
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dudv") then         ![J / (mol m^3)]
        calctype_internal = 48
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "jtco") then			![]
        calctype_internal = 49
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dpdt") then			![MPa/K]
        calctype_internal = 50
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "ve") then			![m^3/mol]
        calctype_internal = 51
        gl%converttype = 3
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "he") then			![J/mol]
        gl%calc_ref = .true.  ! calculate reference state
        calctype_internal = 52
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "ge") then			![J/mol]
        gl%calc_ref = .true.  ! calculate reference state
        calctype_internal = 53
        gl%converttype = 1
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "b12") then			![m^3/mol]
        calctype_internal = 54
        gl%converttype = 3
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "gammagd") then		![-]
        calctype_internal = 55
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "pr") then			![MPa]
        calctype_internal = 56
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dbdt") then			![m^3/(mol T)]
        calctype_internal = 57
        gl%converttype = 3
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dcdt") then			![m^6/(mol^2 T)]
        calctype_internal = 58
        gl%converttype = 4
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dpdd") then			![(Mpa m^3) / mol]
        calctype_internal = 59
        gl%converttype = 3
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d2pdd2") then		![Mpa/(mol/m^3)^2]
        calctype_internal = 60
        gl%converttype = 4
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d2pddt") then		![(Mpa m^3) / (mol K)]
        calctype_internal = 61
        gl%converttype = 3
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d2pdt2") then		![Mpa / K^2]
        calctype_internal = 62
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dddt") then         !
        calctype_internal = 63
        gl%converttype = 2
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dspin") then		![mol/m^3]
        calctype_internal = 64
        gl%converttype = 2
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "phase") then
        calctype_internal = 65
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "af") then    ![-]
        calctype_internal = 66
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "tdensmax") then     ![K]
        calctype_internal = 67
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "tboyle") then     ![K]
        calctype_internal = 68
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "tjinv") then     ![K]
        calctype_internal = 69
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "tjtinv") then     ![K]
        calctype_internal = 70
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dpipdd") then
        calctype_internal = 71
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d2pipdd2") then
        calctype_internal = 72
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d2bdt2") then        ![-]
        calctype_internal = 73
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d2cdt2") then        ![-]
        calctype_internal = 74
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d2ddt2") then        ![-]
        calctype_internal = 75
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d3bdt3") then        ![-]
        calctype_internal = 76
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d3cdt3") then        ![-]
        calctype_internal = 77
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d3ddt3") then        ![-]
        calctype_internal = 78
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d4bdt4") then        ![-]
        calctype_internal = 79
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d4cdt4") then        ![-]
        calctype_internal = 80
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d4ddt4") then        ![-]
        calctype_internal = 81
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "b_calc_num") then    ![-]
        calctype_internal = 82
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "c_calc_num") then    ![-]
        calctype_internal = 83
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "d_calc_num") then    ![-]
        calctype_internal = 84
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "neff") then    ![-]
        calctype_internal = 85
        !***********************************************************************************************************************
    endif



    if (calctype_internal .eq. 0) then
        TREND_EOS_RESULT = -9935.d0
        errorflag = -9935
        return
    end if

    TREND_EOS_RESULT = PROP_EOS(gl, calctype_internal, input, prop1, prop2, fluids, moles, EOS_indicator, MIX_indicator, path, errorflag)
    if(errorflag .lt. 0) return
    call convert_units_out(gl, calctype_internal, unitdefinition, errorflag, moles, TREND_EOS_RESULT)

    if (gl%zero_comp) call revert_zero_inpt(gl, fluids, moles, eos_indicator)

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF



    end function MAKE_FUNC_NAME(TREND_EOS)

    double precision function MAKE_FUNC_NAME(ANC_EQ) ( calctype_arg, input_arg, prop1_arg, prop2_arg, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, unitdefinition_arg,errorflag, gl_handle) result(ANC_EQ_RESULT)
    !##########################################################################################
#define LOCAL_FUNC_NAME() ANC_EQ
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################
    implicit none

    MAKE_ARG_CHAR(12), intent(inout) :: calctype_arg
    MAKE_ARG_CHAR(12), intent(inout) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg



    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    !Define input variables
    character (12) :: input, unit
    character(12) :: calctype
    double precision :: prop1, prop2, prop1_arg, prop2_arg, wm_mix, T, p
    character (30), dimension(30) :: fluids
    double precision, dimension (30) :: moles
    character (255) :: path
    integer, dimension (30) :: EOS_indicator
    integer :: MIX_indicator, unitin
    character (1) :: propID
    integer :: calctype_internal
    integer :: ididit
    character (255) :: errorcodes
    character (20) :: unitdefinition
    logical :: fluid_present, Tgiven, pgiven, limits
    integer :: i,nr_fld, errorflag, nrsubst
    integer :: IS_ERROR

    !-------------------------------------------------------------------------------------------------------------------------------------------------

    !##########################################################################################
    !Preprocessor definition start
    STRING_TO_F(calctype, 12)
    STRING_TO_F(input, 12)
#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(unitdefinition,20)

    !Preprocessor definition end
    !##########################################################################################
    ANC_EQ_RESULT = 0.d0
    !Reset internal calctype
    calctype_internal = 0
    errorflag = 0

    prop1 = prop1_arg
    prop2 = prop2_arg

    unitin = get_unitin(unitdefinition)
    if(unitin < 0) then
        errorflag = unitin
        return
    end if

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if(errorflag.ne.0) then
        ANC_EQ_RESULT = errorflag
        return
    end if
    i = sizeof(gl)
    !default settings for all calculations:
    gl%calc_ref = .false.  ! calculate reference state
    gl%transport = 0       ! needed to check the range of validity for transport properties; 1 for transport properties, 0 for every other property
    gl%VLE_needed = .false.
    gl%converttype = 0
    gl%vir = .false.




    !dummy setup call to guarantte memory allocation
    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    if(gl%seawater .or. gl%el_present) then
        errorflag = -12800
    end if

    call uppertolower_char(unitdefinition,len(unitdefinition))


    !Check for errors:
    if(errorflag.ne.0) then
        ANC_EQ_RESULT = errorflag
        return
    end if


    !input to lower case
    call uppertolower_char(input,len(input))
    call uppertolower_char(calctype,len(calctype))


    propID = "t"
    Call check_triv_input(gl,input, propID, ididit)
    if (ididit == 1) then
        Tgiven = .true.
        T = prop1
    else if (ididit == 2) then
        Tgiven = .true.
        T = prop2
    else
        Tgiven = .false.
    end if

    propID = "p"
    Call check_triv_input(gl,input, propID, ididit)
    if (ididit == 1) then
        pgiven = .true.
        p = prop1
    else if (ididit == 2) then
        pgiven = .true.
        p = prop2
    else
        pgiven = .false.
    end if

    propID = "&"
    Call check_triv_input(gl,input, propID, ididit)


    !***********************************************************************************************************************
    if (gl%ncomp /= 1) then        !components more than 1 --> not defined
        ANC_EQ_RESULT = -5223.d0
        errorflag = ANC_EQ_RESULT
        return
    end if

    !***********************************************************************************************************************
    if((trim(calctype) .eq. "tmelt") .and. (pgiven .eq. .true.)) then

        if ((p .lt. gl%ptp(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9907.d0
        elseif ((p .gt. gl%pmaxfluid(1)) .and. (gl%hold_limits .eq. .true.))  then
            ANC_EQ_RESULT = -9932.d0
        else
            ANC_EQ_RESULT = tmelt_eq(gl,p, 1)
            if (abs(anc_eq_result) < 1.d-10) anc_eq_result = -5400.d0
        end if
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "pmelt".and. (Tgiven .eq. .true.)) then

        if ((gl%pmelttype(1) == 24) .or. (gl%pmelttype(1) == 20)) then
            if ((T .lt. gl%pmeltmintemp(1)) .and. (gl%hold_limits .eq. .true.)) then
                ANC_EQ_RESULT = -9909.d0
            elseif ((T .gt. gl%pmeltmaxtemp(1)) .and. (gl%hold_limits .eq. .true.)) then
                ANC_EQ_RESULT = -9910.d0
            else
                ANC_EQ_RESULT = pmelt_eq(gl,T, 1)
            end if
        else

            if ((T .lt. gl%ttp(1)) .and. (gl%hold_limits .eq. .true.)) then
                ANC_EQ_RESULT = -9909.d0
            elseif ((T .gt. gl%Tmaxfluid(1)) .and. (gl%hold_limits .eq. .true.)) then
                ANC_EQ_RESULT = -9913.d0
            else
                ANC_EQ_RESULT = pmelt_eq(gl,T, 1)
            end if
        end if
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "tsub".and. (pgiven .eq. .true.)) then
        if ((p .lt. 1.d-12) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9933.d0
        elseif ((p .gt. gl%ptp(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9908.d0
        else
            ANC_EQ_RESULT = tsub_eq(gl,p, 1, errorflag)
        end if
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "psub".and. (tgiven .eq. .true.)) then
        if ((T .lt. 1.d-12) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9911.d0
        elseif ((T .gt. gl%ttp(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9910.d0
        else
            ANC_EQ_RESULT = psub_eq(gl,T, 1)
        end if
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dliq".and. (tgiven .eq. .true.)) then
        if ((T .lt. gl%ttp(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9909.d0
        elseif ((T .gt. gl%tc(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9910.d0
        else
            ANC_EQ_RESULT = dl_eq(gl,T, 1)
        end if
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "dvap".and. (tgiven .eq. .true.)) then
        if ((T .lt. gl%ttp(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9909.d0
        elseif ((T .gt. gl%tc(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9910.d0
        else
            ANC_EQ_RESULT = dv_eq(gl,T, 1)
        end if
        !***********************************************************************************************************************
    elseif(trim(calctype) .eq. "pvap".and. (tgiven .eq. .true.)) then
        if ((T .lt. gl%ttp(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9909.d0
        elseif ((T .gt. gl%tc(1)) .and. (gl%hold_limits .eq. .true.)) then
            ANC_EQ_RESULT = -9910.d0
        else
            ANC_EQ_RESULT = vp_eq(gl,T, 1)
        end if
        !***********************************************************************************************************************
    else
        if ((trim(calctype) .ne. "tmelt") .and. (trim(calctype) .ne. "pmelt") .and. (trim(calctype) .ne. "tsub") .and. &
            & (trim(calctype) .ne. "psub") .and. (trim(calctype) .ne. "pvap") .and. (trim(calctype) .ne. "dliq") .and. &
            & (trim(calctype) .ne. "dvap")) then
            ANC_EQ_RESULT = -9935.d0
        else
            ANC_EQ_RESULT = -9955.d0
        end if
    end if

    if(ANC_EQ_RESULT.lt.1d-12) errorflag = ANC_EQ_RESULT

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end function MAKE_FUNC_NAME(ANC_EQ)
    !##################################################################
    !TREND_SPEC_EOS function collects fluid/mixture specific information
    !fluids         character(30),dim(30)   fluid/mixture calculations are conducted with
    !moles          double,dim(30)          composition  calculations are conducted with
    !EOS_indicator  integer,dim(30)         equation of state indicator calculations are conducted with
    !                                       1: Helmholtz
    !                                       2: SRK
    !                                       3: PR
    !                                       4: LKP
    !                                       5: Generalized EOS (51: based on Alexandrov 52: based on Span/Wagner 53: based on Sun/Ely)
    !                                       6: PCSAFT
    !                                       7:
    !                                       8: RKM
    !                                       9: COSTALD
    !MIX_indicator  integer                 indicator for mixing rule
    !                                       1:      Helmholtz default,
    !                                       110:    All components are mixed according to the linear mixing rule
    !                                       111:    check if binary mix files are available, if not use linear mixing rule
    !                                       120:    All components are mixed according to the Lorentz-Berthelot mixing rule.
    !                                       121:    check if binary mix files are available, if not use Lorentz-Berthelot mixing rule.
    !                                       2:      mixing rule according to SRK model
    !                                       3:      mixing rule according to PR model
    !                                       4:      mixing rule according to LKP model
    !                                       5:      mixing rule according to Gen EOS model
    !                                       6:      mixing rule according to PC SAFT model
    !                                       7:
    !                                       8:      mixing rule according to RKM model
    !                                       9:      mixing rule according to COSTALD model
    !path           chracter(255)           main directory of TREND
    !unitdefintion  character(20)           choose molar/specific input and output
    !limits_text    character(30),dim(30)   desciption of the fluid property or limit:
    !                                       1:  molar mass
    !                                       2:  temperature at triple point
    !                                       3:  pressure at triple point
    !                                       4:  temperature at crtical point
    !                                       5:  pressure at critical point
    !                                       6:  density at critical point
    !                                       7:  acentric factor
    !                                       8:  minimum specified temperature of eos
    !                                       9:  maximum specified temperature of eos
    !                                       10: maximum specified pressure of eos
    !                                       11: maximum specified density of eos
    !                                       12: cas-nr -> value: -1000
    !limits_values  double,dim(30,31)          value of the corresponding property or limi
    !##################################################################
    subroutine MAKE_FUNC_NAME(TREND_SPEC_EOS) (fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, unitdefinition_arg, limits_text_arg, limits_values, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() TREND_SPEC_EOS
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################


    implicit none


#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: char_allo
    integer(int_ptr_kind()), intent(inout) :: limits_text_arg

#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(inout) ::  fluids_arg
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(inout) ::  limits_text_arg
#ENDIF

    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg



    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    integer:: errorflag,e
    integer :: unitin
    character(255):: path
    character(20) :: unitdefinition
    integer :: nf, ne, nm, i
    character (30), dimension (30) :: fluids, fluids_save
    double precision, dimension (30) :: moles, moles_save, x_fluid1, x_fluid2, x_sol, x_hyd, x_known
    character (30), dimension (30) :: limits_text
    integer, dimension (30) :: EOS_indicator
    integer :: MIX_indicator, iter, iPhase, iFlash, comp_save
    double precision, dimension(30,31) :: limits_values, temp
    double precision, dimension(5) :: phasefrac, rho
    double precision ::  temptrip, presstrip, rhovap_est, rholiq_est
#IF DEFINED (VALIDATION)
    !###ptdiag vars
    double precision, dimension(30):: z
    !!! if no pressure / temperature is specified i
    double precision:: p_spec, T_spec
    double precision, dimension(6):: pt_return
    double precision, dimension(6):: pt_return_save
    double precision, dimension(6,2):: rho_return
    double precision, dimension(30,6):: x_return
    integer:: points_found, upper_limit_npoints
    !####ptdiag vars
#ENDIF
    character(12):: input
    double precision:: prop1,prop2

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
        STRING_ARRAY_TO_F(limits_text, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(char_allo(30))
    char_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=char_allo)
    fluids = char_allo

    char_allo = limits_text
    call safearray_to_chararray(limits_text_arg,30, FORTRAN_char_vektor=char_allo)
    limits_text = char_allo
#ELSE
    STRING_TO_F(fluids, 30)
    STRING_TO_F(limits_text, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(unitdefinition,20)

    !Preprocessor definition end
    !##########################################################################################

    unitin = get_unitin(unitdefinition)
    if(unitin < 0) then
        errorflag = unitin
        limits_values = unitin
        return
    end if

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if(errorflag /= 0) then
        limits_values = errorflag
        return
    endif

    input = ''
    input = 'TP'
    prop1 = 300.d0
    prop2 = 1.d0
    errorflag = 0

    call uppertolower_char(unitdefinition,len(unitdefinition))


    !                 1     2       3       4       5      6              7           8       9    10    11     12
    limits_text = (/'MW','Ttrip','ptrip','Tcrit','pcrit','Dcrit','AF','Tmin','Tmax','pmax','Dmax','','','','','','','','','','','','','','','','','','',''/)
    limits_values = 0.d0

    !dummy setup call to guarantte memory allocation
    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
#IF DEFINED (VALIDATION)

    if (gl%ncomp > 1) then
        upper_limit_npoints = 200
        prop1 = 0.d0
        prop2 = 0.d0
        call ptdiag(gl,moles, prop1, prop2, pt_return, rho_return, x_return, points_found, errorflag)
        if (errorflag == 0) then
            do i = 1,upper_limit_npoints
                if (gl%pointID(i) == 1) then
                    exit
                endif
            enddo
            if (i < upper_limit_npoints+1) then
                limits_values(4,gl%ncomp+1) = gl%T_pts(i)
                limits_values(5,gl%ncomp+1) = gl%p_pts(i)
            endif
        endif
        errorflag = 0
        i = 202
    endif
#ENDIF

    if (errorflag == 0) then

        if(gl%seawater) then

            fluids_save = gl%components
            moles_save = gl%molfractions
            comp_save = gl%ncomp

            gl%wm(gl%salpos-1) = gl%sea%wm_sea

            iFlash = 8 !for triple point
            x_known(1) = 1.D0
            x_fluid1 = 0.d0
            x_fluid2 = 0.d0
            x_sol = 0.d0
            x_fluid1(1) = 1.D0
            x_fluid2(1) = 1.D0
            x_hyd = 0.D0
            x_sol(1) = 1.D0

            gl%solidtype(1) = 1
            gl%solidtype(2) = 0

            rhovap_est = 0.D0
            rholiq_est = 0.D0

            iFlash = 8
            iphase = 2
            temptrip = 265.d0
            presstrip = 500.d-6

            fluids = ' '
            fluids(1) = 'seawater'
            moles = 0.d0
            moles(1) = 1.d0
            gl%components = fluids
            gl%molfractions = moles
            gl%ncomp = 1

            gl%solid_pos = 1

            call Set_coef_H20(gl,1)

            call ptflash_solid_NC_3P(gl,presstrip, Temptrip, x_known, rho, x_fluid1, x_fluid2, x_sol, x_hyd, rhovap_est, &
                & rholiq_est, Phasefrac, iFlash, iphase, iter, errorflag)

            !gl%seacalc = .false.
            gl%ttp(gl%salpos-1) = temptrip
            gl%ptp(gl%salpos-1) = presstrip

            gl%components = fluids_Save
            gl%molfractions = moles_Save
            gl%ncomp = comp_save

            limits_values(4,gl%salpos-1) = -12800.d0
            limits_values(5,gl%salpos-1) = -12800.d0


        end if

        if (gl%ncomp == 1) then
            limits_values(1,1) = gl%wm(1)
        else
            call wm_mix_calc(gl,limits_values(1,gl%ncomp+1))
#IF DEFINED (VALIDATION)
            if (i < upper_limit_npoints+1) then
                if (gl%unitin == 2) then
                    limits_values(6,gl%ncomp+1) = gl%rholiq_pts(i) * limits_values(1,gl%ncomp+1)
                else
                    limits_values(6,gl%ncomp+1) = gl%rholiq_pts(i)
                endif
            endif
#ENDIF
        end if
        do i = 1, gl%ncomp
            limits_values(1,i) = gl%wm(i)
            limits_values(2,i) = gl%ttp(i)
            limits_values(3,i) = gl%ptp(i)
            limits_values(4,i) = gl%tc(i)
            limits_values(5,i) = gl%pc(i)

            if (gl%unitin == 2) then
                limits_values(6,i) = gl%rhoc(i) * gl%wm(i)
            else
                limits_values(6,i) = gl%rhoc(i)
            endif
            if (gl%substcasnr(i) == trim('999-999-999')) limits_values(6,i) = gl%rhoc(i) / gl%Factor

            limits_values(7,i) = gl%accen(i)
            limits_values(8,i) = gl%tminfluid(i)
            limits_values(9,i) = gl%tmaxfluid(i)
            limits_values(10,i) = gl%pmaxfluid(i)
            if (gl%unitin == 2) then
                limits_values(11,i) = gl%rhomaxfluid(i) * gl%wm(i)
            else
                limits_values(11,i) = gl%rhomaxfluid(i)
            endif
            if (gl%substcasnr(1) == trim('999-999-999')) limits_values(11,i) = gl%rhomaxfluid(i) / gl%Factor
        end do

        if(gl%seawater) then
            fluids(gl%salpos-1) = 'seawater'
            do i=gl%salpos,gl%ncomp
                limits_values(:,i) = limits_values(:,i)
                fluids(i) = gl%components(i)
                limits_values(4:11,gl%salpos-1) = -12800.d0

            end do
            fluids(gl%ncomp+1) = 'mixture'
        end if

    else
        limits_values = errorflag
    end if

    if (gl%zero_comp)then
        call revert_zero_inpt(gl, fluids, moles, eos_indicator)
        temp(:,1:gl%ncomp+1) = limits_values(:,1:gl%ncomp+1)
        limits_values(:,1:gl%ncomp+1) = 0.d0
        limits_values(:,gl%comp_map) = temp(:,1:gl%ncomp)
        limits_values(:,count(eos_indicator /= 0)+1) = temp(:,gl%ncomp+1)


    endif

#IF DEFINED(MAKE_MATLAB)

#ELIF DEFINED(MAKE_SAFEARR)
    char_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=char_allo)
    char_allo = limits_text
    call chararray_to_safearray(limits_text_arg,30, FORTRAN_char_vektor=char_allo)
    deallocate(char_allo)
#ELSE
    limits_text_arg = limits_text
    fluids_arg = fluids
#ENDIF

    end subroutine MAKE_FUNC_NAME(TREND_SPEC_EOS)

    subroutine MAKE_FUNC_NAME(CAS_FROM_FLUID) (fluids_arg, EOS_indicator, MIX_indicator, path_arg, CASNR, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() CAS_FROM_FLUID
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    !define input variables
    character (30), dimension(30) :: fluids
    integer, dimension(30), intent(inout) :: EOS_indicator
    integer, intent(inout) :: MIX_indicator
    character (255) :: path
    !define output variables
    character (12), intent (out) :: CASNR

    character (12) :: input
    double precision :: prop1, prop2
    double precision, dimension(30) :: moles

    integer :: unitin
    integer :: errorflag, i

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    !Preprocessor definition end
    !##########################################################################################
    !set dummy value
    unitin = 1

    CASNR = ''
    input = 'tp'
    prop1 = 300.d0
    prop2 = 1.d0
    moles = 0.d0
    moles(1:count(fluids /= '')) = 1.d0 / count(fluids /= '')

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if (errorflag /= 0) then
        write(CASNR,*)errorflag
        return
    endif
    gl%calc_ref = .false.  ! no need to calculate reference state
    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property

    call setup (gl,input, prop1, prop2, fluids, moles, path,EOS_indicator, mix_indicator, errorflag)

    if(gl%seawater .or. gl%el_present) then
        errorflag = -12800
    end if

    if (errorflag /= 0) then
        write(CASNR,*)errorflag
    else
        CASNR = gl%substcasnr(1)
    end if
    CASNR = ADJUSTL(CASNR)

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF


    end subroutine MAKE_FUNC_NAME(CAS_FROM_FLUID)

    !------------------------------------------------
    !Function for composition convertion
    !------------------------------------------------
    subroutine MAKE_FUNC_NAME(COMP) (fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, unitdefinition_arg, composition, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() COMP
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------



    !definie input:
    character(30), dimension(30) :: fluids
    double precision, dimension(30), intent(inout) :: moles
    integer, dimension(30), intent(inout) :: EOS_indicator!, unitdefinition
    integer, intent(inout) :: MIX_indicator
    character (255) :: path
    character(20) :: unitdefinition
    character(12) :: input
    double precision :: prop1, prop2, wm_mix
    integer :: errorflag, converttype            !dummy for setup
    double precision, dimension (30), intent(out) :: composition
    integer :: i, comp_save, n_zero_comp

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(unitdefinition,20)

    !Preprocessor definition end
    !##########################################################################################

    converttype = comp_convert_flag(unitdefinition)
    if(converttype .le. 0) then
        errorflag = -123456
        return
    end if

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,converttype,gl_handle, errorflag)
    if (errorflag /=0) return

    prop1 = 300.d0
    prop2 = 1.d0
    input = trim('tp')
    gl%zero_spec = .false.
    !gl%unitin = 1

    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator,errorflag)

    call wm_mix_calc(gl, wm_mix)

    if(converttype == 1) then
        converttype = 2
        if(gl%zero_comp) then
            converttype = 2
            comp_save = gl%ncomp
            !gl%ncomp = maxval(gl%comp_map)
            n_zero_comp = maxval(gl%comp_map)-gl%ncomp
            gl%moles_zero_orig_spec = gl%moles_zero_orig
            call convert_fractions(gl, converttype, wm_mix, gl%moles_zero_orig_spec, n_zero_comp)
            gl%ncomp = comp_save
            gl%zero_spec = .true.
        else
            call convert_fractions(gl, converttype, wm_mix, moles)
        end if
    end if

    if (gl%zero_comp) call revert_zero_inpt(gl, fluids, moles, eos_indicator)
    !if ((gl%zero_comp) .and. (.not. gl%zero_spec)) call revert_zero_vector(gl,composition)

    composition = moles
    if(gl%zero_comp) then
        moles = gl%moles_zero_orig
    end if
    if(abs(sum(moles(:)) - 1.d0) > 1.d-10) then
        errorflag = -9950
    end if


#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF


    end subroutine MAKE_FUNC_NAME(COMP)!##########################################################################################


    subroutine MAKE_FUNC_NAME(TRIPLE_POINT) (Temp, press, fluids_arg, path_arg, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() TRIPLE_POINT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF

    MAKE_ARG_CHAR(255), intent(in) ::  path_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    character (12) :: input
    double precision, intent (out) :: Temp, press
    character (30), dimension(30) :: fluids
    double precision, dimension(30) :: moles
    character (255) :: path
    integer, dimension(30) :: EOS_indicator
    integer:: MIX_indicator
    double precision, dimension(30) ::  x_vap, x_liq, x_sol, x_hyd, x_known
    double precision, dimension (3) :: phasefrac, rho

    double precision :: rhovap_est, rholiq_est

    integer:: errorflag, iphase, iter, iFlash, i
    integer :: unitin !dummy for control_fluids

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1
    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        Temp = errorflag
        press = errorflag
        return
    end if

    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property

    !Call setup to read fluid files and check inputs
    Temp = 300.D0
    press = 1.D0
    input = "tp+"
    moles = 0.d0
    moles(1) = 1.d0
    EOS_indicator = 0
    MIX_indicator = 0
    EOS_indicator(1) = 1
    MIX_indicator = 1

    call setup (gl,input, Temp, press, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        Temp = errorflag
        press = errorflag
        return
    end if

    if (gl%ncomp > 1) then
        errorflag = -9902
        Temp = errorflag
        press = errorflag
        return
    end if

    !Composition of all phases is known (pure substance)
    x_known(1) = 1.D0
    x_vap(1) = 1.D0
    x_liq(1) = 1.D0
    x_hyd = 0.D0
    x_sol(1) = 1.D0

    rhovap_est = 0.D0
    rholiq_est = 0.D0

    iFlash = 8
    iphase = 2
    gl%solidtype(2) = 0
    gl%solid_pos = 1

    if (gl%Fluidlist_hydrate(1) == "co2") then
        !CO2
        Temp = 216.5D0
        press = 0.517D0
        gl%solidtype(1) = 2
    elseif (gl%Fluidlist_hydrate(1) == "water") then
        !H2O
        Temp = 273.D0
        press = 611.D-6
        gl%solidtype(1) = 1
    else
        !error, fluid not yet implemented
        errorflag = -12902
        Temp = errorflag
        press = errorflag
        return
    end if

    call ptflash_solid_NC_3P(gl,press, Temp, x_known, rho, x_vap, x_liq, x_sol, x_hyd, rhovap_est, &
        & rholiq_est, Phasefrac, iFlash, iphase, iter, errorflag)

    if (gl%zero_comp) call revert_zero_inpt(gl, fluids, moles, eos_indicator)

    if (errorflag /= 0) then
        Temp = errorflag
        press = errorflag
        return
    end if

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(TRIPLE_POINT)

    SUBROUTINE MAKE_FUNC_NAME(ALL_UNCTY) (input_arg, prop1_arg, prop2_arg, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, UNC_D, UNC_U, UNC_H, UNC_S, UNC_CP, UNC_CV, UNC_WS, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() ALL_UNCTY
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

    MAKE_ARG_CHAR(12), intent(in) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    double precision, intent(out):: UNC_D, UNC_U, UNC_H, UNC_S, UNC_CP, UNC_CV, UNC_WS

    double precision :: prop1, prop2, prop1_arg, prop2_arg
    character (30), dimension(30) :: fluids
    character (255) :: path
    integer, dimension(30) :: EOS_indicator
    integer:: MIX_indicator
    character (12) :: input

    double precision, dimension(30) :: moles

    integer, intent(out) :: errorflag
    integer :: unitin ! dummy for control_fluids
    integer :: ILIMITS, i

    double precision:: x_Phase(30,5)    ! vector conaining the compositions of all phases
    integer:: nrofphases                ! at this point: only 1 or 2 implemented
    !Indicate which phases are present
    integer:: phasetype(5)              !phasetype contains the phase indicator number
    !define variables for calculating
    double precision :: t, d, p
    double precision :: dvap
    double precision :: dliq
    double precision :: vapfrac

    double precision :: h, s
    double precision:: rho(5)           ! vector containing the densities of all phases
    double precision :: x_liq(30)
    double precision :: x_vap(30)


    !Uncertainty variables
    integer:: uncty_call_prop, iter, nrsubst, IFlash, phase
    LOGICAL :: twophase

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(input,12)

    !Preprocessor definition end
    !##########################################################################################

    prop1 = prop1_arg
    prop2 = prop2_arg

    unitin = 1
    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)

    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if

    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property


    ILIMITS = 0
    errorflag = 0
    nrofphases = 0
    UNC_D = 0.D0
    UNC_U = 0.D0
    UNC_H = 0.D0
    UNC_S = 0.D0
    UNC_CP = 0.D0
    UNC_CV = 0.D0
    UNC_WS = 0.D0

    twophase = .false.
    vapfrac = 0.D0 !Not needed since input is only T and p

    !trim input
    call uppertolower_char(input,len(input))

    !if (EOS_ind == 2) then
    !    UNC_D = -2908
    !    UNC_U = -2908
    !    UNC_H = -2908
    !    UNC_S = -2908
    !    UNC_CP = -2908
    !    UNC_CV = -2908
    !    UNC_WS = -2908
    !    return
    !end if
    if (.not.allocated(gl%uncty)) allocate(gl%uncty)
    !!call setup - >  initializing, reading fluid files
    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if

    !Catch wrong inputs
    if (gl%ncomp > 1) then
        errorflag = -7000      !No mixtures allowed
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if
    if (gl%Eq_type(1) > 1) then
        errorflag = -7002
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !calculate CALC
    !______________________________________________________________________________
    if (input == 'td') then
        t = prop1
        d = prop2

        !check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call PhaseDet_pure(gl,p, T, d, dvap, dliq, phase, vapfrac, nrofphases, errorflag)
        else  ! mixture
            nrsubst = 0
            call PhaseDet_td(gl,p, t, moles, rho, x_Phase, phasetype, vapfrac, d, nrofphases, errorflag)
        end if
        !______________________________________________________________________________
        !calculate TP
    else if (input == 'tp') then
        t = prop1
        p = prop2
        !check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call PhaseDet_pure_tp(gl,p, t, d, dvap, dliq, phase, vapfrac, nrofphases, errorflag)
        else  !mixture
            nrsubst = 0
            call PhaseDet(gl,p, t, moles, rho, x_Phase, phasetype, vapfrac, nrofphases, errorflag)
        end if

        !______________________________________________________________________________
        !calculate PH
    else if (input == 'ph') then
        p = prop1
        h = prop2
        !check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call PhaseDet_ph_pure(gl,p, t, d, dvap, dliq, phase, vapfrac, h, nrofphases, errorflag)
        else    !mixture
            nrsubst = 0
            call PhaseDet_ph(gl,p, t, moles, rho, x_phase, phasetype, vapfrac, h, nrofphases, errorflag)
        end if
        !______________________________________________________________________________
        !calculate PS
    else if (input == 'ps') then
        p = prop1
        s = prop2
        !check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call PhaseDet_ps_pure(gl,p, t, d, dvap, dliq, phase, vapfrac, s, nrofphases, errorflag)
        else    !mixture
            nrsubst = 0
            call PhaseDet_ps(gl,p, t, moles, rho, x_phase, phasetype, vapfrac, s, nrofphases, errorflag)
        end if
        !______________________________________________________________________________
    else if (input == 'tliq') then
        t = prop1
        ! check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call Flash_Pure_PhaseBoundary(gl,p, t, dvap, dliq, 1, errorflag, iter, nrsubst)
        else    !mixture
            nrsubst = 0
            iFlash = 3
            p = 0.d0
            call Flash_PhaseBoundary(gl,p, t, moles, x_vap, x_liq, 0.d0, 0.d0, vapfrac, iFlash,&
                &  0, errorflag, iter)
        end if
        vapfrac = 0.d0
        nrofphases = 2
        !______________________________________________________________________________
    else if (input == 'tvap') then
        t = prop1
        ! check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call Flash_Pure_PhaseBoundary(gl,p, t, dvap, dliq, 1, errorflag, iter, nrsubst)
        else    !mixture
            nrsubst = 0
            iFlash = 4
            p = 0.d0
            call Flash_PhaseBoundary(gl,p, t, moles, x_vap, x_liq, 0.d0, 0.d0, vapfrac, iFlash,&
                &  0, errorflag, iter)
        end if
        vapfrac = 1.d0
        nrofphases = 2
        !______________________________________________________________________________
    else if (input == 'pliq') then
        p = prop1
        ! check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call Flash_Pure_PhaseBoundary(gl,p, t, dvap, dliq, 2, errorflag, iter, nrsubst)
        else    !mixture
            nrsubst = 0
            iFlash = 1
            t = 0.d0
            call Flash_PhaseBoundary(gl,p, t, moles, x_vap, x_liq, 0.d0, 0.d0, vapfrac, iFlash,&
                &  0, errorflag, iter)
        end if
        vapfrac = 0.d0
        nrofphases = 2
        !______________________________________________________________________________
    else if (input == 'pvap') then
        p = prop1
        ! check whether pure fluid or mixture
        if (gl%ncomp == 1) then !pure fluid
            nrsubst = 1
            call Flash_Pure_PhaseBoundary(gl,p, t, dvap, dliq, 2, errorflag, iter, nrsubst)

        else    !mixture
            nrsubst = 0
            iFlash = 2
            t = 0.d0
            call Flash_PhaseBoundary(gl,p, t, moles, x_vap, x_liq, 0.d0, 0.d0, vapfrac, iFlash,&
                &  0, errorflag, iter)
        end if
        vapfrac = 1.d0
        nrofphases = 2
    end if

    !errorflag =! 0
    if (errorflag /= 0) then
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if

    !---end of Phasedet---


    !errorflag = 0
    if (nrofphases == 2) then    !2phase                                                                       !2phase
        if (gl%ncomp == 1) then                                                                                !2phase, pure fluid
            errorflag = -7003
            UNC_D = errorflag
            UNC_U = errorflag
            UNC_H = errorflag
            UNC_S = errorflag
            UNC_CP = errorflag
            UNC_CV = errorflag
            UNC_WS = errorflag
            input=gl%inptorig
            return
        else
            !2phase, mixture
        end if

    else        !1phase
        !Code kommt unten

    end if
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    !Calculate the uncertainties of the following properties:
    !H  : 1
    !U  : 2
    !CV : 3
    !S  : 4
    !CP : 5
    !WS : 6
    !t = prop1
    !p = prop2
    !d = rhomix_calc(gl,t, p, 0.D0, 0, 1)
    !-----------------------------------------------------
    !TEST OF UNCERTAINTY ROUTINES!!
    !Get density and enthalpy uncertainty (The uncertainty in density is always given by the authors and updated no matter which uncertainty is calculated)
    Uncty_call_prop = 1
    call callUncty(gl,uncty_call_prop, t, d, twophase, vapfrac, errorflag, path)
    if (errorflag == 0) then
        UNC_H = gl%uncty%uncty_h
        UNC_D = gl%uncty%uncty_d
    else
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if
    !Get internal energy uncertainty
    Uncty_call_prop = 2
    call callUncty(gl,uncty_call_prop, t, d, twophase, vapfrac, errorflag, path)
    if (errorflag == 0) then
        UNC_U = gl%uncty%uncty_u
    else
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if
    !Get isochoric heat capacity uncertainty
    Uncty_call_prop = 3
    call callUncty(gl,uncty_call_prop, t, d, twophase, vapfrac, errorflag, path)
    if (errorflag == 0) then
        UNC_CV = gl%uncty%uncty_cv
    else
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if
    !Get entropy uncertainty
    Uncty_call_prop = 4
    call callUncty(gl,uncty_call_prop, t, d, twophase, vapfrac, errorflag, path)
    if (errorflag == 0) then
        UNC_S = gl%uncty%uncty_s
    else
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if
    !Get isobaric heat capacity uncertainty
    Uncty_call_prop = 5
    call callUncty(gl,uncty_call_prop, t, d, twophase, vapfrac, errorflag, path)
    if (errorflag == 0) then
        UNC_CP = gl%uncty%uncty_cp
    else
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if
    !Get sound speed uncertainty
    Uncty_call_prop = 6
    call callUncty(gl,uncty_call_prop, t, d, twophase, vapfrac, errorflag, path)
    if (errorflag == 0) then
        UNC_WS = gl%uncty%uncty_w
    else
        UNC_D = errorflag
        UNC_U = errorflag
        UNC_H = errorflag
        UNC_S = errorflag
        UNC_CP = errorflag
        UNC_CV = errorflag
        UNC_WS = errorflag
        input=gl%inptorig
        return
    end if
    !-----------------------------------------------------


    !check limits
    call check_limits (gl,input, t, p, d, dliq, dvap, nrofphases, x_phase, phasetype, ILIMITS)

    if (ILIMITS /= 0) then
        UNC_D = ILIMITS
        UNC_U = ILIMITS
        UNC_H = ILIMITS
        UNC_S = ILIMITS
        UNC_CP = ILIMITS
        UNC_CV = ILIMITS
        UNC_WS = ILIMITS
        errorflag = ILIMITS
        input=gl%inptorig
        return
    end if

    ! für Krohne Umrechnung in spezifische Einheiten
    !call wm_mix_calc(wm_mix)
    !UNC_D = UNC_D*wm_mix
    !UNC_U = UNC_U/wm_mix
    !UNC_H = UNC_H/wm_mix
    !UNC_S = UNC_S/wm_mix
    !UNC_CP = UNC_CP/wm_mix
    !UNC_CV = UNC_CV/wm_mix

    input=gl%inptorig

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(ALL_UNCTY)


    subroutine MAKE_FUNC_NAME(LITERATURE_REF) (fluids_arg, moles, EOS_indicator, MIX_indicator, prop_arg, path_arg,  reference_out, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() LITERATURE_REF
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################


    implicit none

    MAKE_ARG_CHAR(10), intent(in) ::  prop_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    character (30), dimension(30) :: fluids
    character (10) :: prop  !equal calctype
    character (255) :: path
    character (1000) :: reference_out

    integer, dimension(30) :: EOS_indicator
    integer, intent(inout):: MIX_indicator
    character (12) :: input
    double precision :: prop1, prop2
    double precision, dimension (30) :: moles

    integer :: unitin ! dummy value for control_fluids
    integer :: i,j, errorflag, nf

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo

#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(prop,10)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if (errorflag /= 0) then
        reference_out = 'Setup error'
        return
    endif
    if (.not. allocated(gl%litref)) allocate(gl%litref)




    errorflag = 0
    input = 'tp'
    prop1 = 300d0
    prop2 = 0.1d0

    call setfluid (gl, fluids, nf, errorflag)

    if(nf .gt. 2.d0) then
        errorflag = -5247.d0
        reference_out = 'Literature reference only available for pure fluids and binary mixtures'
        return
    end if

    nf = 0
    do i = 1, 2
        if (EOS_indicator(i) /= 0) then
            nf = nf + 1
        endif
    enddo
    moles = 0.d0
    if (nf == 1) then
        moles(1) = 1.d0
        !EOS_indicator = '1;1'
    else
        moles(1:2) = 0.5d0
        !EOS_indicator = '1;1;1'
    endif

    if(any(fluids(:) == 'seawater')) then
        reference_out = 'See Manual for reference'
        return
    end if


    call setup (gl, input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
    if (errorflag /= 0) then
        reference_out = 'Setup error'
        if(any(fluids(:) == 'seawater')) then
            reference_out = 'See Manual for reference'
        end if
        return
    endif
    call uppertolower_char(prop, len(prop))

    select case (trim(prop))
    case ('p','d','t','u','h','s','g','a','cp','cv','ws','bvir','cvir','z')
        if (gl%ncomp == 1) then
            reference_out = gl%litref%lit_ref_res(1)
        elseif (gl%ncomp == 2) then
            reference_out = gl%litref%lit_ref_mix
        endif
    case ('de')
        reference_out = gl%litref%lit_ref_de(1)
    case ('tcx')
        reference_out = gl%litref%lit_ref_tcx(1)
    case ('stn')
        reference_out = gl%litref%lit_ref_stn(1)
    case ('eta')
        reference_out = gl%litref%lit_ref_eta(1)
    case ('mlt')
        reference_out = gl%litref%lit_ref_mlt(1)
    case ('sbl')
        reference_out = gl%litref%lit_ref_sbl(1)
        case default
        reference_out = 'Invalid property input'
    end select
#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF
    end subroutine MAKE_FUNC_NAME(LITERATURE_REF)


    SUBROUTINE MAKE_FUNC_NAME(FLASH_EXPERT) (input_arg, prop1_arg, prop2_arg, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, &
        & xliq_in, xvap_in, rholiq_est, rhovap_est, iPhase_try, xliq, xvap, propliq, propvap, vapfrac, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() FLASH_EXPERT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    ! EXPERT routine for the calculation of a two phase flash
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! ALL INITIAL ESTIMATES NECESSARY HAVE TO BE GIVEN BY THE USER!!!
    ! THE RESULT IS NOT EVALUATED FOR STABILITY, THUS METASTABLE STATES MIGHT BE CALCULATES
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! 2-phase flash calculation with t-p, p-h, p-s and t-d as input parameters possible
    ! This routine returns the compositions and all thermodynamic properties of the coexisting phases
    !---------------------------------------------------
    ! Input parameters:
    !   prop1, prop2                - according to the chosen flash type: T,p / p,s / p,h
    !   xliq, xvap                  - initial estimates for the phase composition
    !   rhovap_est, rholiq_est      - initial estimates for the liquid and vapor densities (optional)
    !   EOS_indicator               - specifies which equation of state shall be used
    !   path                        - path to the fluid files
    !   iPhase_try                  - 0 - >  let the density solver choose the likely density for both phases,  vap: iphase = 0, liq : iphase = 0
    !                               - 1 - >  LLE assumed, vap: iphase = 1, liq : iphase = 0
    !                               - 2 - >  VLE assumed, vap: iphase = 2, liq : iphase = 0
    !                               - 3 - >  LLE assumed, vap: iphase = 0, liq : iphase = 1
    !                               - 4 - >  LLE assumed, vap: iphase = 1, liq : iphase = 1
    !                               - 5 - >  VLE assumed, vap: iphase = 2, liq : iphase = 1
    !                               - 6 - >  VLE assumed, vap: iphase = 1, liq : iphase = 2
    ! Output parameters:
    !   xliq, xvap          composition vectors, length 30
    !   propliq, propvap    property vectors of the two phases, properties are positioned in the following order:
    !                       P, T, D, U, H, S, G, A, CP, CV, WS - lengh 30
    !   vapfrac             vapor fraction: returns -2 for superheated vapor and -1 for subcooled liquid

    !No specific input, as only for expert users

    implicit none

    MAKE_ARG_CHAR(12), intent(in) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg


    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    character (12) :: input
    character(20) :: unitdefinition
    double precision :: prop1, prop2, prop1_arg, prop2_arg
    character (30), dimension(30) :: fluids
    double precision, dimension(30) :: moles
    character (255) :: path
    integer, dimension(30) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin ! dummy value for control_fluids
    double precision, dimension(30):: xliq_in, xvap_in

    double precision, dimension(30), intent(out) :: xliq
    double precision, dimension(30), intent(out) :: xvap
    double precision, dimension(30), intent(out) :: propliq
    double precision, dimension(30), intent(out) :: propvap
    double precision, intent(out) :: vapfrac

    double precision:: t, p, h, s, dliq, dvap
    double precision:: rho(5)
    integer :: nrsubst, errorflag, phasetype(5), iFlash, iter
    integer :: i, iphase_try
    double precision:: rhovap_est, rholiq_est
    double precision :: wm_mix
    double precision, dimension(5) :: wm_phase

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(input,12)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1

    prop1 = prop1_arg
    prop2 = prop2_arg

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if (errorflag /= 0) then
        xliq = errorflag
        xvap = errorflag
        propliq = errorflag
        propvap = errorflag
        vapfrac = errorflag
        input=gl%inptorig
        return
    end if

    !input to lower case
    call uppertolower_char (input, len(input))

    !call setup
    errorflag = 0
    xvap = 0.D0
    xliq = 0.D0
    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property
    gl%unitin = 1


    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    if(gl%seawater .or. gl%el_present) then
        errorflag = -12800
    end if

    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        xliq = errorflag
        xvap = errorflag
        propliq = errorflag
        propvap = errorflag
        vapfrac = errorflag
        input=gl%inptorig
        return
    end if

    !Check whether all necessary input variables have (proper) values
    !---------------------------
    !check input variables (T,p,h,s)
    !---------------------------
    if (input == 'tp') then
        if (prop1 <= 0.D0) then
            errorflag = - 9911
        end if
        if (prop2 <= 0.D0) then
            errorflag = - 9933
        end if
    end if
    if (input == 'ph') then
        if (prop1 <= 0.D0) then
            errorflag = - 9933
        end if
    end if
    if (input == 'ps') then
        if (prop1 <= 0.D0) then
            errorflag = - 9933
        end if
    end if
    if (input == 'td') then
        !if (prop1 <= 0.D0) then
        !    errorflag = - 9911
        !    input=inptorig
        !    return
        !end if
        !if (prop1 <= 0.D0) then
        !    errorflag = - 9922
        !    input=inptorig
        !    return
        !end if
        errorflag = -9955
        xliq = errorflag
        xvap = errorflag
        propliq = errorflag
        propvap = errorflag
        vapfrac = errorflag
        input=gl%inptorig
        return
    end if
    if (input == 'tvap') then
        if (prop1 <= 0.D0) then
            errorflag = - 9911
        end if
        if (prop2 <= 0.D0) then
            errorflag = - 9933
        end if
    end if
    if (input == 'tliq') then
        if (prop1 <= 0.D0) then
            errorflag = - 9911
        end if
        if (prop2 <= 0.D0) then
            errorflag = - 9933
        end if
    end if
    if (input == 'pvap') then
        if (prop1 <= 0.D0) then
            errorflag = - 9933
        end if
        if (prop2 <= 0.D0) then
            errorflag = - 9911
        end if
    end if
    if (input == 'pliq') then
        if (prop1 <= 0.D0) then
            errorflag = - 9933
        end if
        if (prop2 <= 0.D0) then
            errorflag = - 9911
        end if
    end if

    if (gl%zero_comp) then
        xliq_in(1:gl%ncomp) = xliq_in(gl%comp_map(1:gl%ncomp))
        xliq_in(gl%ncomp+1:30) = 0.d0
        xvap_in(1:gl%ncomp) = xvap_in(gl%comp_map(1:gl%ncomp))
        xvap_in(gl%ncomp+1:30) = 0.d0
    endif

    !read moles from the character variable and store it in a double type variable
    call moles_incheck(gl,xliq_in, errorflag)
    xliq = xliq_in
    if (errorflag /= 0) then
        xliq = errorflag
        xvap = errorflag
        propliq = errorflag
        propvap = errorflag
        vapfrac = errorflag
        input=gl%inptorig
        return
    end if
    call moles_incheck(gl,xvap_in, errorflag)
    xvap = xvap_in
    if (errorflag /= 0) then
        xliq = errorflag
        xvap = errorflag
        propliq = errorflag
        propvap = errorflag
        vapfrac = errorflag
        input=gl%inptorig
        return
    end if

    !---------------------------
    !check initial estimates for the compositions
    do i = 1, gl%ncomp
        if ((xliq(i) <= 0.D0) .or. (xvap(i) <= 0.D0)) then
            errorflag = -9951
        end if
    end do
    !---------------------------
    !check iphase_try
    if (iphase_try < 0 .or. iphase_try > 6) then
        !Set the iphase_try such that VLE is assumed (iphase_try = 5)
        iphase_try = 5
    end if
    !---------------------------

    if (errorflag /= 0) then
        xliq = errorflag
        xvap = errorflag
        propliq = errorflag
        propvap = errorflag
        vapfrac = errorflag
        input=gl%inptorig
        return
    end if

    ! ---------------------------------------------------------------------
    !  TD-FLASH
    ! ---------------------------------------------------------------------
    !if (input == 'td') then
    !    t = prop1
    !    d = prop2
    !    if (ncomp == 1) then
    !        nrsubst = 1     ! pure fluid
    !        call PhaseDet_pure(p, T, d, dvap, dliq, phase, vapfrac, nrofphases, errorflag)
    !        xliq = moles
    !        xvap = moles
    !    else
    !        nrsubst = 0     ! mixture
    !        errorflag = -9902
    !        return
    !    end if
    !end if


    ! ---------------------------------------------------------------------
    !  TP-FLASH
    ! ---------------------------------------------------------------------
    if (input == 'tp') then
        t = prop1
        p = prop2
        if (gl%ncomp == 1) then
            errorflag = -9901 !pure fluid
        else
            nrsubst = 0     ! mixture
            !call PhaseDet(p, t, moles, rho, x_Phase, phasetype, vapfrac, nrofphases, errorflag)
            call Flash_pT_calc(gl,p, t, moles, xvap, xliq, rhovap_est, rholiq_est, vapfrac, iPhase_try, errorflag, iter)
            dvap = gl%rho_vap
            dliq = gl%rho_liq
        end if
    end if

    ! ---------------------------------------------------------------------
    !  PH-FLASH
    ! ---------------------------------------------------------------------
    if (input == 'ph') then
        p = prop1
        h = prop2
        if (gl%ncomp == 1) then
            nrsubst = 1  !pure fluid
            errorflag = -9901
        else
            nrsubst = 0     ! mixture
            !call PhaseDet_ph(p, t, moles, rho, x_Phase, phasetype, vapfrac, h, nrofphases, errorflag)
            call Flash_ph(gl,p, t, moles, xvap, xliq, rhovap_est, rholiq_est, vapfrac, h, iPhase_try, errorflag, iter)
            dvap = rho(phasetype(1))
            dliq = rho(phasetype(2))
        end if
    end if

    ! ---------------------------------------------------------------------
    !  PS-FLASH
    ! ---------------------------------------------------------------------
    if (input == 'ps') then
        p = prop1
        s = prop2
        if (gl%ncomp == 1) then
            nrsubst = 1     ! pure fluid
            errorflag = -9901
        else
            nrsubst = 0     ! mixture
            !call PhaseDet_ps(p, t, moles, rho, x_Phase, phasetype, vapfrac, s, nrofphases, errorflag)
            call Flash_ps(gl,p, t, moles, xvap, xliq, rhovap_est, rholiq_est, vapfrac, s, iPhase_try, errorflag, iter)
            dvap = rho(phasetype(1))
            dliq = rho(phasetype(2))
        end if
    end if

    ! ---------------------------------------------------------------------
    !  OTHER INPUT CODES
    ! ---------------------------------------------------------------------
    if ((input == 'tliq') .or. (input == 'tvap') .or. (input == 'pliq') .or. (input == 'pvap')) then
        if (gl%ncomp == 1) then
            nrsubst = 1     ! pure fluid
            xliq = moles
            xvap = moles
            if (input(1:1) == 'P') then   ! vapor pressure given
                p = prop1
                t = prop2
                dvap = rhovap_est
                dliq = rholiq_est
                call Flash_Pure_PhaseBoundary(gl,p, t, dvap, dliq, 2, errorflag, iter, nrsubst)
                !call VLEpurePres(p,t,dvap,dliq,errorflag, 1)
            else                        ! Sat. Temperature given
                t = prop1
                p = prop2
                dvap = rhovap_est
                dliq = rholiq_est
                call Flash_Pure_PhaseBoundary(gl,p, t, dvap, dliq, 1, errorflag, iter, nrsubst)
                !call VLEpure(p,t,dvap,dliq,errorflag, 1)
            end if
            vapfrac = 1.d0
            if (input(2:4) == 'LIQ') vapfrac = 0.d0
        else
            nrsubst = 0     ! mixture
            !   - BUBBLE POINT: P AND x' VEXTOR GIVEN   --  iFlash = 1
            !   - DEW POINT:    P AND x" VECTOR GIVEN   --  iFlash = 2
            !   - BUBBLE POINT: T AND x' VEXTOR GIVEN   --  iFlash = 3
            !   - DEW POINT:    T AND x" VECTOR GIVEN   --  iFlash = 4
            iFlash = 0
            if (input == 'pliq') then
                iFlash = 1
                p = prop1
                t = prop2
                xliq = moles
            end if
            if (input == 'pvap') then
                iFlash = 2
                p = prop1
                t = prop2
                xvap = moles
            end if
            if (input == 'tliq') then
                iFlash = 3
                t = prop1
                p = prop2
                xliq = moles
            end if
            if (input == 'tvap') then
                iFlash = 4
                t = prop1
                p = prop2
                xvap = moles
            end if
            dvap = rhovap_est
            dliq = rholiq_est
            !call Flash_PhaseBoundary(p, t, moles, xvap, xliq, dvap, dliq, vapfrac, iFlash, 0, errorflag, iter)
            call Flash_PhaseBoundary_calc(gl,p, t, moles, xvap, xliq, dvap, dliq, vapfrac, iFlash,&
                & iPhase_try, 1, errorflag, iter)
            if (errorflag == 0) then
                dliq = gl%rho_liq
                dvap = gl%rho_vap
            end if
        end if
    end if

    ! ---------------------------------------------------------------------
    ! calculate all thermodynamic properties
    ! ---------------------------------------------------------------------
    if (errorflag == 0) then
        !if ((0.d0 <= vapfrac) .and. (vapfrac <= 1.d0) .and. (xvap(1) /= 0.d0)) then   ! two-phase
        ! calculate the properties of the liquid phase
        gl%molfractions = xliq
        call reduced_parameters_calc(gl,t) !Dummy temperature 300 K for the SRK
        propliq(1) = t
        propliq(2) = p
        propliq(3) = dliq
        propliq(4) = u_calc(gl,t, dliq, nrsubst)
        propliq(5) = h_calc(gl,t, dliq, nrsubst)
        propliq(6) = s_calc(gl,t, dliq, nrsubst)
        propliq(7) = g_calc(gl,t, dliq, nrsubst)
        propliq(8) = A_CALC(gl,t, dliq, nrsubst)
        propliq(9) = cp_calc(gl,t, dliq, nrsubst)
        propliq(10) = cv_calc(gl,t, dliq, nrsubst)
        propliq(11) = ws_calc(gl,t, dliq, nrsubst)

        !call wm_mix_calc(gl, wm_mix)
        !wm_phase(1) = wm_mix

        ! calculate the properties of the vapor phase
        gl%molfractions = xvap
        call reduced_parameters_calc(gl,t) !Dummy temperature 300 K for the SRK
        propvap(1) = t
        propvap(2) = p
        propvap(3) = dvap
        propvap(4) = u_calc(gl,t, dvap, nrsubst)
        propvap(5) = h_calc(gl,t, dvap, nrsubst)
        propvap(6) = s_calc(gl,t, dvap, nrsubst)
        propvap(7) = g_calc(gl,t, dvap, nrsubst)
        propvap(8) = A_CALC(gl,t, dvap, nrsubst)
        propvap(9) = cp_calc(gl,t, dvap, nrsubst)
        propvap(10) = cv_calc(gl,t, dvap, nrsubst)
        propvap(11) = ws_calc(gl,t, dvap, nrsubst)

        !call wm_mix_calc(gl, wm_mix)
        !wm_phase(2) = wm_mix

    else
        xliq = errorflag
        xvap = errorflag
        propliq = errorflag
        propvap = errorflag
        vapfrac = errorflag
    end if


    !If the SRK is used, check whether an ideal part exists
    !Andreas November 2013
    Do i = 1, gl%ncomp
        if(gl%Eq_type(i) == 2) then
            !---------------------------------------------------------
            !If constants B and C for the SRK cp0 model are 0, no model is implemented
            if ((dabs(gl%B_cv0(i)) < 1.D-8) .and. (dabs(gl%C_cv0(i)) < 1.D-8)) then
                !No ideal part for SRK exists
                errorflag = -2908
                propvap(4) = errorflag
                propvap(5) = errorflag
                propvap(6) = errorflag
                propvap(7) = errorflag
                propvap(8) = errorflag
                propvap(9) = errorflag
                propvap(10) = errorflag
                propvap(11) = errorflag
                propliq(4) = errorflag
                propliq(5) = errorflag
                propliq(6) = errorflag
                propliq(7) = errorflag
                propliq(8) = errorflag
                propliq(9) = errorflag
                propliq(10) = errorflag
                propliq(11) = errorflag
            end if
        end if
    end do

    input=gl%inptorig
    if (gl%zero_comp)then
        call revert_zero_vector(gl, xliq)
        call revert_zero_vector(gl, xvap)
    endif

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF


    End subroutine MAKE_FUNC_NAME(FLASH_EXPERT)

    subroutine MAKE_FUNC_NAME(FLASH_NC_3P_EXPERT) (input_arg, prop1_arg, prop2_arg, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, xliq1_in, xliq2_in, xvap_in, &
        & rholiq1_est, rholiq2_est, rhovap_est, xliq1, xliq2, xvap, propliq1, propliq2, propvap, Phasefrac, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() FLASH_NC_3P_EXPERT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################


    implicit none

    MAKE_ARG_CHAR(12), intent(in) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg


    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    double precision :: p, t
    double precision :: prop1, prop2, prop1_arg, prop2_arg
    character(30), dimension(30) :: fluids
    double precision, dimension(30) :: moles
    character (255) :: path
    integer, dimension(30) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin

    double precision, dimension(30):: xliq1_in, xliq2_in, xvap_in

    double precision, dimension(30), intent(out) :: xvap, xliq1, xliq2
    double precision, dimension(3), intent(out) :: Phasefrac

    double precision, dimension(5) :: rho, wm_phase
    integer :: errorflag, iter, iFlash, nrsubst

    double precision, intent(in):: rhovap_est, rholiq1_est, rholiq2_est
    double precision :: dvap, dliq1, dliq2

    double precision, dimension(30), intent(out) :: propliq1
    double precision, dimension(30), intent(out) :: propliq2
    double precision, dimension(30), intent(out) :: propvap

    character(12) :: input
    double precision:: wm_mix
    character(20) :: unitdefinition

    integer:: i

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo

#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(input,12)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1

    prop1 = prop1_arg
    prop2 = prop2_arg

    !input to lower case
    call uppertolower_char(input, len(input))

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if (errorflag /= 0) then
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
        input=gl%inptorig
        return
    end if

    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property

    !call setup
    errorflag = 0
    xvap = 0.D0
    xliq1 = 0.D0
    xliq2 = 0.D0
    gl%unitin = 1


    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
        input=gl%inptorig
        return
    end if


    if (input == 'tp') then
        iflash = 7
        t = prop1
        p = prop2
        if ((Phasefrac(1) <= 0.D0) .and. (Phasefrac(2) <= 0.D0) .and. (Phasefrac(3) <= 0.D0)) then
            Phasefrac = 1.D0 / 3.D0
        end if
    elseif (input == 'tl2') then
        iflash = 6
        t = prop1
        p = prop2
        if ((Phasefrac(1) <= 0.D0) .and. (Phasefrac(2) <= 0.D0) .and. (Phasefrac(3) <= 0.D0)) then
            Phasefrac = 0.5D0
        end if
    elseif (input == 'tvap') then
        iflash = 5
        t = prop1
        p = prop2
        if ((Phasefrac(1) <= 0.D0) .and. (Phasefrac(2) <= 0.D0) .and. (Phasefrac(3) <= 0.D0)) then
            Phasefrac = 0.5D0
        end if
    elseif (input == 'tliq') then
        iflash = 4
        t = prop1
        p = prop2
        if ((Phasefrac(1) <= 0.D0) .and. (Phasefrac(2) <= 0.D0) .and. (Phasefrac(3) <= 0.D0)) then
            Phasefrac = 0.5D0
        end if
    elseif (input == 'pl2') then
        iflash = 3
        p = prop1
        t = prop2
        if ((Phasefrac(1) <= 0.D0) .and. (Phasefrac(2) <= 0.D0) .and. (Phasefrac(3) <= 0.D0)) then
            Phasefrac = 0.5D0
        end if
    elseif (input == 'pvap') then
        iflash = 2
        p = prop1
        t = prop2
        if ((Phasefrac(1) <= 0.D0) .and. (Phasefrac(2) <= 0.D0) .and. (Phasefrac(3) <= 0.D0)) then
            Phasefrac = 0.5D0
        end if
    elseif (input == 'pliq') then
        iflash = 1
        p = prop1
        t = prop2
        if ((Phasefrac(1) <= 0.D0) .and. (Phasefrac(2) <= 0.D0) .and. (Phasefrac(3) <= 0.D0)) then
            Phasefrac = 0.5D0
        end if
    else
        errorflag = -9955
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
        input=gl%inptorig
        return
    end if


    if (t <= 0.D0) then
        errorflag = - 9911
    end if
    if (p <= 0.D0) then
        errorflag = - 9933
    end if

    if (gl%zero_comp) then
        xliq1_in(1:gl%ncomp) = xliq1_in(gl%comp_map(1:gl%ncomp))
        xliq1_in(gl%ncomp+1:30) = 0.d0
        xliq2_in(1:gl%ncomp) = xliq2_in(gl%comp_map(1:gl%ncomp))
        xliq2_in(gl%ncomp+1:30) = 0.d0
        xvap_in(1:gl%ncomp) = xvap_in(gl%comp_map(1:gl%ncomp))
        xvap_in(gl%ncomp+1:30) = 0.d0
    endif

    !read moles from the character variable and store it in a double type variable
    call moles_incheck(gl,xliq1_in, errorflag)
    xliq1 = xliq1_in
    if (errorflag /= 0) then
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
        input=gl%inptorig
        return
    end if
    call moles_incheck(gl,xliq2_in, errorflag)
    xliq2 = xliq2_in
    if (errorflag /= 0) then
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
        input=gl%inptorig
        return
    end if
    call moles_incheck(gl,xvap_in, errorflag)
    xvap = xvap_in
    if (errorflag /= 0) then
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
        input=gl%inptorig
        return
    end if
    !---------------------------
    !check initial estimates for the compositions
    do i = 1, gl%ncomp
        if ((xliq2(i) <= 0.D0) .or. (xliq1(i) <= 0.D0) .or. (xvap(i) <= 0.D0)) then
            errorflag = -9951
        end if
    end do
    !---------------------------

    if (gl%ncomp < 2) then
        errorflag = -9901
    end if

    if (errorflag /= 0) then
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
        input=gl%inptorig
        return
    end if


    call ptflash_NC_3P(gl,p, t, moles, rho, xvap, xliq1, xliq2, rhovap_est, &
        & rholiq1_est, rholiq2_est, Phasefrac, iFlash, iter, errorflag)

    dvap = rho(1)
    dliq1 = rho(2)
    dliq2 = rho(3)

    ! ---------------------------------------------------------------------
    ! calculate all thermodynamic properties
    ! ---------------------------------------------------------------------
    if (errorflag == 0) then
        !if ((0.d0 <= vapfrac) .and. (vapfrac <= 1.d0) .and. (xvap(1) /= 0.d0)) then   ! two-phase
        ! calculate the properties of the liquid phase 1
        nrsubst = 0
        gl%molfractions = xvap
        call reduced_parameters_calc(gl,T)
        propvap(1) = t
        propvap(2) = p
        propvap(3) = dvap
        propvap(4) = u_calc(gl,t, dvap, nrsubst)
        propvap(5) = h_calc(gl,t, dvap, nrsubst)
        propvap(6) = s_calc(gl,t, dvap, nrsubst)
        propvap(7) = g_calc(gl,t, dvap, nrsubst)
        propvap(8) = A_CALC(gl,t, dvap, nrsubst)
        propvap(9) = cp_calc(gl,t, dvap, nrsubst)
        propvap(10) = cv_calc(gl,t, dvap, nrsubst)
        propvap(11) = ws_calc(gl,t, dvap, nrsubst)

        !mol specific gl_handle
        ! if (gl%unitin == 2) then
        ! call wm_mix_calc(gl, wm_mix)
        !
        !     wm_phase(1) = wm_mix
        ! end if
        !
        ! calculate the properties of the liquid phase 2
        gl%molfractions = xliq1


        call reduced_parameters_calc(gl,t)
        propliq1(1) = t
        propliq1(2) = p
        propliq1(3) = dliq1
        propliq1(4) = u_calc(gl,t, dliq1, nrsubst)
        propliq1(5) = h_calc(gl,t, dliq1, nrsubst)
        propliq1(6) = s_calc(gl,t, dliq1, nrsubst)
        propliq1(7) = g_calc(gl,t, dliq1, nrsubst)
        propliq1(8) = A_CALC(gl,t, dliq1, nrsubst)
        propliq1(9) = cp_calc(gl,t, dliq1, nrsubst)
        propliq1(10) = cv_calc(gl,t, dliq1, nrsubst)
        propliq1(11) = ws_calc(gl,t, dliq1, nrsubst)

        !mol specific gl_handle
        !if (gl%unitin == 2) then
        !call wm_mix_calc(gl, wm_mix)
        !
        !    wm_phase(2) = wm_mix
        !end if


        ! calculate the properties of the vapor phase
        gl%molfractions = xliq2
        call reduced_parameters_calc(gl,t)
        propliq2(1) = t
        propliq2(2) = p
        propliq2(3) = dliq2
        propliq2(4) = u_calc(gl,t, dliq2, nrsubst)
        propliq2(5) = h_calc(gl,t, dliq2, nrsubst)
        propliq2(6) = s_calc(gl,t, dliq2, nrsubst)
        propliq2(7) = g_calc(gl,t, dliq2, nrsubst)
        propliq2(8) = A_CALC(gl,t, dliq2, nrsubst)
        propliq2(9) = cp_calc(gl,t, dliq2, nrsubst)
        propliq2(10) = cv_calc(gl,t, dliq2, nrsubst)
        propliq2(11) = ws_calc(gl,t, dliq2, nrsubst)

        !mol specific gl_handle
        ! if (gl%unitin == 2) then
        ! call wm_mix_calc(gl, wm_mix)
        !     wm_phase(3) = wm_mix
        ! end if
    else
        xliq1 = errorflag
        xliq2 = errorflag
        xvap = errorflag
        propliq1 = errorflag
        propliq2 = errorflag
        propvap = errorflag
        Phasefrac = errorflag
    end if


    !If the SRK is used, check whether an ideal part exists
    !Andreas November 2013
    Do i = 1, gl%ncomp
        if(gl%Eq_type(1) == 2) then
            !---------------------------------------------------------
            !If constants B and C for the SRK cp0 model are 0, no model is implemented
            if ((dabs(gl%B_cv0(i)) < 1.D-8) .and. (dabs(gl%C_cv0(i)) < 1.D-8)) then
                !No ideal part for SRK exists
                errorflag = -2908
                propvap(4) = errorflag
                propvap(5) = errorflag
                propvap(6) = errorflag
                propvap(7) = errorflag
                propvap(8) = errorflag
                propvap(9) = errorflag
                propvap(10) = errorflag
                propvap(11) = errorflag
                propliq1(4) = errorflag
                propliq1(5) = errorflag
                propliq1(6) = errorflag
                propliq1(7) = errorflag
                propliq1(8) = errorflag
                propliq1(9) = errorflag
                propliq1(10) = errorflag
                propliq1(11) = errorflag
                propliq2(4) = errorflag
                propliq2(5) = errorflag
                propliq2(6) = errorflag
                propliq2(7) = errorflag
                propliq2(8) = errorflag
                propliq2(9) = errorflag
                propliq2(10) = errorflag
                propliq2(11) = errorflag
            end if
        end if
    end do

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF


    input=gl%inptorig
    if (gl%zero_comp)then
        call revert_zero_vector(gl, xliq1)
        call revert_zero_vector(gl, xliq2)
        call revert_zero_vector(gl, xvap)
    endif

    End subroutine MAKE_FUNC_NAME(FLASH_NC_3P_EXPERT)


    !##################################################################
    !flash3 function performs same calculations as trend_eos but gives properties of each present phase
    !input          character(12)           specifies the given state point where the property has to be calculated, possible inputs are:
    !                                       tp (prop1 is temperature, prop2 is pressure)
    !                                       td (prop1 is temperature, prop2 is density)
    !                                       ps(prop1 is pressure, prop2 is entropy)
    !                                       ph (prop1 is pressure, prop2 is enthalpy)
    !                                       tliq (prop1 is temperature on bubble line, prop2 is ignored)
    !                                       tvap(prop1 is temperature on dew line, prop2 is ignored)
    !                                       pliq (prop1 is pressure on bubble line, prop2 is ignored)
    !                                       pvap (prop1 is pressure on dew line, prop2 is ignored)
    !prop1, prop2   double                  values for state point depending on input
    !fluids         character(30),dim(30)   fluid/mixture calculations are conducted with
    !moles          double,dim(30)          composition  calculations are conducted with
    !eos_indicator  integer,dim(30)         equation of state indicator calculations are conducted with
    !                                       1: helmholtz
    !                                       2: srk
    !                                       3: pr
    !                                       4: lkp
    !                                       5: generalized eos (51: based on alexandrov 52: based on span/wagner 53: based on sun/ely)
    !                                       6: pcsaft
    !                                       7:
    !                                       8: rkm
    !                                       9: costald
    !mix_indicator  integer                 indicator for mixing rule
    !                                       1:      helmholtz default,
    !                                       110:    all components are mixed according to the linear mixing rule
    !                                       111:    check if binary mix files are available, if not use linear mixing rule
    !                                       120:    all components are mixed according to the lorentz-berthelot mixing rule.
    !                                       121:    check if binary mix files are available, if not use lorentz-berthelot mixing rule.
    !                                       2:      mixing rule according to srk model
    !                                       3:      mixing rule according to pr model
    !                                       4:      mixing rule according to lkp model
    !                                       5:      mixing rule according to gen eos model
    !                                       6:      mixing rule according to pc saft model
    !                                       7:
    !                                       8:      mixing rule according to rkm model
    !                                       9:      mixing rule according to costald model
    !path           chracter(255)           main directory of trend
    !unitdefintion  character(20)           choose molar/specific input and output
    ! 3-phase flash calculation with t-p, p-h, and p-s as input parameters possible
    ! this routine returns the compositions and all thermodynamic properties of the coexisting phases
    !---------------------------------------------------
    ! output parameters:
    !   phasetype           vector  phasetype contains the phase indicator number
    !   phase_text          vector  phase_text contains the abbreviations to all possible phases (vap,liq1,liq2,sol,hyd)
    !e.g.: 2 phases are present: liquid and liquid equilibrium
    !-- >  nrofphases = 2
    !-- >  phasetype(1) = 2 (light liquid)
    !-- >  phasetype(2) = 3 (heavy liquid)
    !e.g.: 1 phase present: liquid
    !-- >  nrofphases = 1
    !-- >  phasetype(1) = 3 (heavy liquid) note: in case of one phase liquid, heavy liquid is used!!
    !phaseindicators: 1: vapor, 2: light liquid, 3: heavy liquid, 4: solid, 5: hydrate
    !   x_phase             composition matrix (5,30)
    !       1   x_vap       - vapor phase composition
    !       2   x_liq1      - (lighter) liquid phase composition
    !       3   x_liq2      - (heavier) liquid phase composition
    !       4   x_sol       - solid phase composition (so far only co2 and h2o are implemented)
    !       5   x_hyd       - hydrate phase compsition
    !   prop_phase          matrix (30,5) with all properties of all phases in equilibrium
    !                       - t, p, d, u, h, s, g, a, cp, cv, ws,      hyd_nr, hydrate_structure, overall_small_cage_occup, overall_large_cage_occup, phase_fraction
    !                       - 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11,          12                 13,                       14,                       15,             16,
    !   prop_overall        - overall properties of phases in equilibrium
    !   lnfug_phase         matrix (30,5) natural logarithm of the fugacities of all components in the phases
    !   chempot_phase       matrix (30,5) chemical potential of all components in the phases
    !   phasefrac           vector (5) that contains the phasefractions of all phases
    !   prop_name_unit      matrix (flash_chardim,3) conatins the property name, symbol, and the corresponding unit
    !##################################################################
    subroutine MAKE_FUNC_NAME(FLASH3) (input_arg, prop1_arg, prop2_arg, fluids_arg, moles, eos_indicator, mix_indicator, path_arg, unitdefinition_arg, phasetype, phase_text_arg, &
        & x_phase, prop_phase,  prop_overall, lnfug_phase, chempot_phase, phasefrac, prop_name_unit_arg, errorflag, gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() FLASH3
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################
    implicit none

    MAKE_ARG_CHAR(12), intent(in) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    integer(int_ptr_kind()), intent(inout) :: phase_text_arg
    integer(int_ptr_kind()), intent(inout) :: prop_name_unit_arg
    character(30), dimension(:,:), allocatable :: char_30_arr_allo
    character(30), dimension(:), allocatable :: char_30_allo
    character(4), dimension(:), allocatable :: char_4_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(inout) ::  fluids_arg
    MAKE_ARG_CHAR_ARRAY(4, 5), intent(inout) ::  phase_text_arg
    MAKE_ARG_CHAR_ARRAY_ARRAY(30, flash_chardim, 3), intent(inout) ::  prop_name_unit_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    character (12) :: input
    character(20) :: unitdefinition
    double precision :: prop1, prop2, prop1_arg, prop2_arg
    character (30), dimension(30) :: fluids
    double precision, dimension(30) :: moles
    character (255) :: path
    integer, dimension(30) :: eos_indicator
    integer :: mix_indicator
    integer :: unitin
    !    double precision, optional, intent(inout) :: pmin, pmax

    double precision, dimension(30, 5), intent(out) :: x_phase
    double precision, dimension(30, 5), intent(out) :: prop_phase
    double precision, dimension(30, 5), intent(out) :: lnfug_phase
    double precision, dimension(30, 5), intent(out) :: chempot_phase
    double precision, dimension(30), intent(out) :: prop_overall
    double precision, dimension(5), intent(out) :: phasefrac
    integer, dimension(5), intent(out) :: phasetype
    character(4), dimension(5) :: phase_text
    character(30), dimension(flash_chardim,3):: prop_name_unit

    double precision, dimension(30) :: molesorig, prop_vec
    double precision, dimension(30) :: xvap, xliq1, xliq2, xsol, xhyd, xhelp, x_spec, x_overall
    double precision:: d, t, p, dliq, dvap, d_phase
    double precision, dimension(5) :: rho, wm_phase, dens_reac
    double precision::  wm_mix, wm_overall
    integer:: nrsubst, errorflag, nrofphases
    integer :: i, j, k, converttype

    !variables needed for the calculation of hydrate enthalpy
    double precision, dimension(30) :: chem_pot, fug_g, x_fluid
    double precision :: dchem_pot_dt_fluid, dchem_pot_dx_fluid, dfug_dt_fluid, dfug_dx_fluid, d_fluid
    double precision :: h_hyd, s_hyd, u_hyd, f_hyd, g_hyd, chempot_hyd
    double precision :: watermol
    integer :: pos_dryice

    !new variables needed to calculate the chemical potentials and fugacities of the fluid phases
    integer :: oir
    double precision, dimension (30):: chem_pot_fluid
    double precision, dimension (30):: lnfi_fluid
    double precision, dimension (30,5) :: chempot

    !double precision, dimension(5) :: wm_phase

    !pure hydrates model
    !!variables needed for the hydrate composition and langmuir constants
    !double precision, dimension(2) :: occup, cij, xh

    ! mixed hydrates 2015
    double precision, dimension(3,30):: cij, occup, occup_single, occup_double !<- cij and occup are used in the commented part only
    double precision, dimension(30):: xh, fug_gas!, occup_ls, occup_ld, occup_sms, occup_smd !<- xh and fug_gas are used in the commented part only


    !##########################################################################################
    !preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
    do i = 1,size(phase_text,1)
        STRING_ARRAY_TO_F(phase_text, 5)
    enddo
    do i = 1,size(prop_name_unit,1)
        do j = 1,size(prop_name_unit,2)
            STRING_ARRAY_ARRAY_TO_F(prop_name_unit, 30)
        end do
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(char_30_allo(30))
    char_30_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=char_30_allo)
    fluids = char_30_allo

    allocate(char_4_allo(5))
    char_4_allo = phase_text
    call safearray_to_chararray(phase_text_arg,4, FORTRAN_char_vektor=char_4_allo)
    phase_text = char_4_allo

    !Monika & Andy: Muss das nicht allocate(char_30_arr_allo(flash_chardim,3)) sein, genau wie im #ELSE Fall??
    allocate(char_30_arr_allo(flash_chardim,2))
    char_30_arr_allo = prop_name_unit
    call safearray_to_chararray(prop_name_unit_arg,30, FORTRAN_char_array=char_30_arr_allo)
    prop_name_unit = char_30_arr_allo
#ELSE
    STRING_TO_F(fluids, 30)
    STRING_TO_F (phase_text, 5)
    STRING_TO_F (prop_name_unit, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(input,12)
    STRING_TO_F(unitdefinition,20)

    !preprocessor definition end
    !##########################################################################################

    prop1 = prop1_arg
    prop2 = prop2_arg

    call uppertolower_char(input,len(input))
    !call uppertolower_char(unitdefinition,len(unitdefinition))

    unitin = get_unitin(unitdefinition)
    if(unitin < 0) then
        errorflag = unitin
        x_phase = errorflag
        prop_phase = errorflag
        phasefrac = errorflag
        phasetype = 0
        return
    end if

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        x_phase = errorflag
        prop_phase = errorflag
        phasefrac = errorflag
        phasetype = 0
        input=gl%inptorig
        return
    end if


    !initialize variables
    nrofphases = 0
    x_phase = 0.d0
    prop_phase = 0.d0
    phasefrac = 0.d0
    phasetype = 0
    xvap = 0.d0
    xliq1 = 0.d0
    xliq2 = 0.d0
    xsol = 0.d0
    xhyd = 0.d0
    chem_pot = 0.d0
    fug_g = 0.d0
    dchem_pot_dt_fluid = 0.d0
    dchem_pot_dx_fluid = 0.d0
    dfug_dt_fluid = 0.d0
    dfug_dx_fluid = 0.d0
    u_hyd = 0.d0
    h_hyd = 0.d0
    s_hyd = 0.d0
    g_hyd = 0.d0
    f_hyd = 0.d0
    lnfug_phase = 0.d0
    chempot_phase = 0.d0
    prop_vec = 0.d0
    dens_reac = 0.d0
    phase_text = ''
    prop_name_unit = ''
    errorflag = 0

    !needed for the chemical potential --> get overall chemical potential
    oir = 0

    !trim input
    call uppertolower_char(input,len(input))

    call uppertolower_char(unitdefinition,len(unitdefinition))

    !andreas jan 2015
    gl%calc_ref = .true.  ! calculate reference state
    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property

    !call setup
    errorflag = 0
    call setup (gl,input, prop1, prop2, fluids, moles, path,eos_indicator, mix_indicator, errorflag)

    ! set prop_name and corresponding units

    if (errorflag == 0) then
        phase_text = (/'vap','liq1','liq2','sol','hyd'/)
        prop_name_unit(:,1) = (/'Temperature','Pressure','Density','Int. energy','Enthalpy','Entropy','Gibbs energy','Helmholtz energy','Isob. heat capacity','Isoch. heat capacity','Speed of sound','Hydration number','Hydrate structure', 'Overall small cage occup','Overall large cage occup','Molecular weight','Phase fraction','Composition','','','','','','','','','','','','','','','','','','',''/)

        ! loop over all propnames
        prop_name_unit(:,2) = (/'T','P','D','U','H','S','G','A','CP','CV','WS','NH','', 'THETA_S^O','THETA_L^O','MW','BETA','x1','x2','x3','x4','x5','x6','x7','x8','x9','x10','x11','x12','x13','x14','x15','x16','x17','x18','x19','x20'/)

        do i=1,flash_chardim
            prop_name_unit(i,3) = PROP_UNIT_INTERFACE(unitdefinition,prop_name_unit(i,2),30,errorflag)
        end do
        prop_name_unit(13,3) = ''

        if (gl%zero_comp) then
            do i=1,len(gl%fluids_zero_orig)

                if (gl%fluids_zero_orig(i)=='')then
                    exit
                end if

                prop_name_unit(17+i,2) = 'x_' // trim(gl%fluids_zero_orig(i))
            end do
        else
            do i=1,gl%ncomp

                prop_name_unit(17+i,2) = 'x_' // trim(gl%components(i))
            end do
        end if
    endif

    !endif
    molesorig = 0.d0
    molesorig = gl%molfractions        ! be aware of gl%molfractions with molar / specific input



    ! irregular input, or problems with fluid file or reference state
    if (errorflag /= 0) then
        x_phase = errorflag
        prop_phase = errorflag
        phasefrac = errorflag
        phasetype = 0
        input=gl%inptorig
        return
    end if


    !gl_handle different input parameters and do all calculations
    call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles, rho, x_phase, phasetype, &
        & phasefrac, nrofphases, nrsubst, errorflag)

    ! ---------------------------------------------------------------------
    ! calculate all thermodynamic properties
    ! ---------------------------------------------------------------------
    if (errorflag == 0) then
        wm_phase = 0.d0
        prop_overall = 0.d0
        do i = 1, nrofphases
            prop_phase(1, phasetype(i)) = t
            prop_phase(2, phasetype(i)) = p
            prop_overall(1) = t
            prop_overall(2) = p
            if (phasetype(i) < 4) then  !fluid phase


                ! calculate the properties of the first phase
                gl%molfractions = x_phase(:,phasetype(i))
                !! if((gl%unitin ==1) .and. (gl%unitstat == 2))
                !! call set_molarspecific(convert, input, moles, prop1, prop2, x_spec, wm_phase)
                !! gl%molefractions = x_spec
                !! end if
                call wm_mix_calc(gl, wm_mix)
                wm_phase(phasetype(i)) = wm_mix
                if (gl%ncomp > 1) then
                    call reduced_parameters_calc(gl,t) !dummy temperature 300 k for the srk
                end if

                if((phasetype(i) .eq. 2) .and. ((gl%seawater) .or. (gl%el_present))) then
                    if(gl%seawater) then
                        gl%seacalc = .true.
                        gl%gecarrier = .true.
                    elseif(gl%el_present) then
                        gl%gecarrier = .true.
                    end if
                    !gl%wm(1) = gl%sea%wm_sea
                elseif((phasetype(i) .eq. 3) .and. ((gl%seawater) .or. (gl%el_present)))then
                    if(gl%seawater) then
                        gl%seacalc = .true.
                        gl%gecarrier = .true.
                    elseif(gl%el_present) then
                        gl%gecarrier = .true.
                    end if
                    !gl%wm(1) = gl%sea%wm_sea
                else
                    gl%seacalc = .false.
                    gl%gecarrier = .false.
                end if

                d_phase = rho(phasetype(i))
                prop_phase(3, phasetype(i)) = d_phase
                if ((gl%gecarrier) .or. (gl%seawater)) then
                    dens_reac(phasetype(i)) = brine_dens(gl, t, p, d_phase)
                end if
                !if constants b and c for the srk cp0 model are 0, no model is implemented
                if ((any(gl%eq_type(1:gl%ncomp) > 1)) .and. ((any(dabs(gl%b_cv0(1:gl%ncomp)) < 1.d-8 )) .or. (any(dabs(gl%c_cv0(1:gl%ncomp)) < 1.d-8 ))) ) then
                    prop_phase(4, phasetype(i)) =-2908
                    prop_phase(5, phasetype(i)) = -2908
                    prop_phase(6, phasetype(i)) = -2908
                    prop_phase(7, phasetype(i)) = -2908
                    prop_phase(8, phasetype(i)) = -2908
                    prop_phase(9, phasetype(i)) = -2908
                    prop_phase(10, phasetype(i)) = -2908
                    prop_phase(11, phasetype(i)) = -2908
                else
                    prop_phase(4, phasetype(i)) = u_calc(gl,t, d_phase, nrsubst)
                    prop_phase(5, phasetype(i)) = h_calc(gl,t, d_phase, nrsubst)
                    prop_phase(6, phasetype(i)) = s_calc(gl,t, d_phase, nrsubst)
                    prop_phase(7, phasetype(i)) = g_calc(gl,t, d_phase, nrsubst)
                    prop_phase(8, phasetype(i)) = a_calc(gl,t, d_phase, nrsubst)
                    prop_phase(9, phasetype(i)) = cp_calc(gl,t, d_phase, nrsubst)
                    prop_phase(10, phasetype(i)) = cv_calc(gl,t, d_phase, nrsubst)
                    prop_phase(11, phasetype(i)) = ws_calc(gl,t, d_phase, nrsubst)
                    prop_phase(16, phasetype(i)) = wm_phase(phasetype(i))
                    if (gl%seacalc .or. gl%gecarrier) then
                        dens_reac(phasetype(i)) = brine_dens(gl, t, p, d_phase)
                    end if
                end if


                !Hier kann die dichte der phase überschrieben werden, bzw. auf einen vektor geschrieben werden.
                !end do
                !end if
                if((phasetype(i) .eq. 2) .and. ((gl%seawater) .or. (gl%el_present))) then
                    if(gl%seawater) then
                        gl%seacalc = .true.
                    elseif(gl%el_present) then
                        gl%gecarrier = .true.
                    end if
                    !gl%wm(1) = gl%sea%wm_sea
                elseif((phasetype(i) .eq. 3) .and. ((gl%seawater) .or. (gl%el_present)))then
                    if(gl%seawater) then
                        watermol = gl%wm(1)
                        gl%wm(1) = gl%sea%wm_sea
                        gl%seacalc = .true.
                        call wm_mix_calc(gl, wm_mix)
                        wm_phase(phasetype(i)) = wm_mix
                        gl%wm(1) = watermol
                    elseif(gl%el_present) then
                        watermol  =gl%wm(1)
                        gl%wm(1) = wm_brine(gl)
                        gl%gecarrier = .true.
                        call wm_mix_calc(gl, wm_mix)
                        wm_phase(phasetype(i)) = wm_mix
                        gl%wm(1) = watermol
                    end if
                    !gl%wm(1) = gl%sea%wm_sea
                else
                    gl%seacalc = .false.
                    gl%gecarrier = .false.
                end if

                !calculate the chemical potential for all components in the fluid phase
                call chempot_calc(gl,t, d_phase, chem_pot_fluid, oir)
                chempot_phase(:,phasetype(i)) = chem_pot_fluid


                !calculate the fugacity for all components in the fluid phase
                call lnf_mix(gl,t, d_phase, p, lnfi_fluid)
                lnfug_phase(:,phasetype(i)) = lnfi_fluid

                if ((gl%zero_comp).and.(.not.gl%check_solid)) then
                    call revert_zero_vector(gl,chempot_phase(:,phasetype(i)))
                    call revert_zero_vector(gl,lnfug_phase(:,phasetype(i)))
                endif


            elseif (phasetype(i) == 4) then     !solid (pure)
                gl%molfractions = x_phase(:,phasetype(i))
                if (gl%solidtype_akt_phase == 1) then         !water
                    prop_phase(3, phasetype(i)) = rho(phasetype(i))
                    prop_phase(4, phasetype(i)) = u_waterice(gl,t, p)
                    prop_phase(5, phasetype(i)) = h_waterice(gl,t, p)
                    prop_phase(6, phasetype(i)) = s_waterice(gl,t, p)
                    prop_phase(7, phasetype(i)) = g_waterice(gl,t, p)
                    prop_phase(8, phasetype(i)) = f_waterice(gl,t, p)
                    prop_phase(9, phasetype(i)) = cp_waterice(gl,t, p)
                    prop_phase(10, phasetype(i)) = -12900
                    prop_phase(11, phasetype(i)) = -12900
                    wm_phase(phasetype(i)) = gl%wm(1)
                    prop_phase(16, phasetype(i)) = gl%wm(1)
                elseif (gl%solidtype_akt_phase == 2) then     !co2
                    prop_phase(3, phasetype(i)) = rho(phasetype(i))
                    prop_phase(4, phasetype(i)) = u_dryice(gl,t, p)
                    prop_phase(5, phasetype(i)) = h_dryice(gl,t, p)
                    prop_phase(6, phasetype(i)) = s_dryice(gl,t, p)
                    prop_phase(7, phasetype(i)) = g_dryice(gl,t, p)
                    prop_phase(8, phasetype(i)) = f_dryice(gl,t, p)
                    prop_phase(9, phasetype(i)) = cp_dryice(gl,t, p)
                    prop_phase(10, phasetype(i)) = -12900
                    prop_phase(11, phasetype(i)) = -12900
                    if(gl%components(1) == 'water') then
                        wm_phase(phasetype(i)) = gl%wm(2)
                        prop_phase(16, phasetype(i)) = gl%wm(2)
                    else
                        wm_phase(phasetype(i)) = gl%wm(1)
                        prop_phase(16, phasetype(i)) = gl%wm(1)
                    end if
                else                                !no solid equation available
                    prop_phase(3, phasetype(i)) = -9904
                    prop_phase(4, phasetype(i)) = -9904
                    prop_phase(5, phasetype(i)) = -9904
                    prop_phase(6, phasetype(i)) = -9904
                    prop_phase(7, phasetype(i)) = -9904
                    prop_phase(8, phasetype(i)) = -9904
                    prop_phase(9, phasetype(i)) = -9904
                    prop_phase(10, phasetype(i)) = -9904
                    prop_phase(11, phasetype(i)) = -9904
                    errorflag = -9904
                end if
            elseif (phasetype(i) == 5) then     !hydrate
                gl%molfractions = x_phase(:,phasetype(i))
                prop_phase(3, phasetype(i)) = rho(phasetype(i))
                prop_phase(9, phasetype(i)) = -12900        !cp
                prop_phase(10, phasetype(i)) = -12900       !cv
                prop_phase(11, phasetype(i)) = -12900       !w

                !get the t and x partial derivatives of the fugacity and the chemical potential of the fluid phase to
                !calculate the entropy and enthalpy of hydrates
                if (phasetype(1) < 4) then !first phase must be a fluid phase in order to calculate the needed derivatives
                    x_fluid = x_phase(:,phasetype(1))
                    d_fluid = rho(phasetype(1))
                    xhyd = x_phase(:,phasetype(i))
                    call hdrt_ancillary_hs(gl,t, d_fluid, p *1.d6, x_fluid, chem_pot, fug_g, errorflag)

                    call hdrt_gibbs_energy(gl,xhyd, chem_pot, g_hyd, errorflag)
                    if (errorflag == 0) then
                        call hdrt_entropy(gl,t, p*1.d6, xhyd, fug_g, s_hyd, errorflag)
                    end if
                    if (errorflag == 0) then
                        call hdrt_enthalpy(gl,t, p*1.d6, xhyd, chem_pot, fug_g,  h_hyd, errorflag)
                    end if
                    if (errorflag == 0) then
                        u_hyd = h_hyd - p * 1.d6 / rho(phasetype(i))
                        f_hyd = g_hyd - p * 1.d6 / rho(phasetype(i))

                        prop_phase(4, phasetype(i)) = u_hyd
                        prop_phase(5, phasetype(i)) = h_hyd
                        prop_phase(6, phasetype(i)) = s_hyd
                        prop_phase(7, phasetype(i)) = g_hyd
                        prop_phase(8, phasetype(i)) = f_hyd
                    else

                        prop_phase(4, phasetype(i)) = -12900
                        prop_phase(5, phasetype(i)) = -12900
                        prop_phase(6, phasetype(i)) = -12900
                        prop_phase(7, phasetype(i)) = -12900
                        prop_phase(8, phasetype(i)) = -12900
                        errorflag = -12900

                    end if

                    !get the langmuir constants, hydration number and cage occupancies for the gas hydrate phase
                    !andreas, jan 2015
                    call hdrt_mole_fract(gl,t,p*1.d6,fug_g,occup,cij,xh,occup_single, occup_double)

                    call wm_mix_calc(gl, wm_mix)
                    wm_phase(phasetype(i)) = wm_mix

                    !pure hydrates
                    !prop_phase(12, phasetype(i)) = xh(1)/xh(2)      !hyd nr
                    !prop_phase(13, phasetype(i)) = occup(1)         !small cage occup
                    !prop_phase(14, phasetype(i)) = occup(2)         !large cage occup
                    !prop_phase(15, phasetype(i)) = cij(1) * 1.d6    !small cage langmuir constant 1/mpa
                    !prop_phase(16, phasetype(i)) = cij(2) * 1.d6    !large cage langmuir constant 1/mpa
                    !mixed hydrates
                    prop_phase(12, phasetype(i)) = xh(1)/sum(xh(2:))      !hyd nr
                    prop_phase(13, phasetype(i)) = gl%hdrt_structure_stable  !hydrate structure
                    prop_phase(14, phasetype(i)) = sum(occup(1,:))         !overall small cage occup
                    prop_phase(15, phasetype(i)) = sum(occup(2,:))         !overall large cage occup
                    prop_phase(16, phasetype(i)) = wm_phase(phasetype(i))
                    !prop_phase(16, phasetype(i)) = sum(cij(1,:)) * 1.d6    !small cage langmuir constant 1/mpa
                    !prop_phase(17, phasetype(i)) = sum(cij(2,:)) * 1.d6    !large cage langmuir constant 1/mpa

                else
                    if ((gl%solidpos_akt_phase == 2) .and. (gl%ncomp == 2)) then !try dry ice in equilibrium with hydrate
                        pos_dryice = gl%solidtype_akt_phase
                        fug_g(1) = fug_dryice(gl,t, p, pos_dryice) *1.d6
                        if (fug_g(1) < 1.d-12) then
                            errorflag = -7779
                        else
                            !fug_co2 = fug_g(1)
                            chem_pot(2) = g_dryice(gl,t, p)
                            !call hdrt_chem_potent_w(t, p*1.d6, fug_co2, chempot_hyd)
                            call hdrt_chem_potent_w(gl,t, p*1.d6, fug_g, chempot_hyd)
                            chem_pot(1) = chempot_hyd

                            xhyd = x_phase(:,phasetype(i))

                            call hdrt_enthalpy(gl,t, p*1.d6, xhyd, chem_pot, fug_g, h_hyd, errorflag)
                        end if
                    else
                        errorflag = -12900
                    end if
                end if

            end if


            if((gl%seacalc) .or. (gl%gecarrier)) then
                prop_phase(3, phasetype(i)) = dens_reac(phasetype(i))
                prop_overall(3) = prop_overall(3) + phasefrac(phasetype(i)) / prop_phase(3, phasetype(i))
            else
                prop_overall(3) = prop_overall(3) + phasefrac(phasetype(i)) / prop_phase(3,phasetype(i)) !density
            end if

            prop_overall(4:8) = prop_overall(4:8) + phasefrac(phasetype(i)) * prop_phase(4:8,phasetype(i))

            if ((gl%zero_comp).and.(.not.gl%check_solid)) call revert_zero_vector(gl,x_phase(:,phasetype(i)))
        end do

        if (dabs(prop_overall(3)) > 1.d-14) then
            prop_overall(3) = 1.d0 / prop_overall(3) !density
        end if
    else
        x_phase = errorflag
        phasefrac = errorflag
        prop_phase = errorflag
        phasetype = errorflag
        input = gl%inptorig
        gl%molfractions = molesorig
        return
    end if

    if((gl%unitin==2) .and. (errorflag == 0)) then
        x_spec = 0.d0
        converttype = 2         ! converting moles to weight fractions
        x_spec = 0.d0

        do i=1,nrofphases
            watermol = gl%wm(1)

            x_spec = x_phase(:,phasetype(i))

            call convert_fractions(gl, converttype, wm_phase(phasetype(i)), x_spec)

            x_phase(:,phasetype(i)) = x_spec
            gl%wm(1) = watermol
        end do

        do i = 1,nrofphases

            prop_vec = prop_phase(:, phasetype(i))


            wm_mix = wm_phase(phasetype(i))

            call convert_flash_spec(gl, prop_vec,  wm_mix)

            prop_phase(:, phasetype(i)) = prop_vec



            prop_vec = ChemPot_phase(:, phasetype(i))

            chempot_phase(1:gl%ncomp,phasetype(i)) = prop_vec(1:gl%ncomp) / gl%wm(1:gl%ncomp)

        end do

        gl%molfractions = molesorig
        call wm_mix_calc(gl, wm_overall)
        call convert_fractions(gl, converttype, wm_overall, molesorig)

        prop_vec = prop_overall

        wm_mix = wm_overall
        call convert_flash_spec(gl, prop_vec,  wm_mix)

        prop_overall = prop_vec

        phasefrac(phasetype(1:nrofphases)) = phasefrac(phasetype(1:nrofphases))*wm_phase(phasetype(1:nrofphases))/wm_mix
    end if

    if(nrofphases .ge. 2) then
        prop_overall(9:11) = -6666.d0  !not available in two-phase-region
    end if

    gl%molfractions = molesorig
    call wm_mix_calc(gl, wm_overall)
    prop_overall(16) = wm_overall

    do i = 1, nrofphases
        !if solids are checked, map the molfractions back to original input
        if (gl%check_solid .and. (gl%ncomp > 1)) then

            x_phase(gl%mapping(1:gl%ncomp),phasetype(i)) = x_phase(1:gl%ncomp,phasetype(i))
            if (gl%zero_comp) call revert_zero_vector(gl,x_phase(:,phasetype(i)))

            chempot_phase(gl%mapping(1:gl%ncomp),phasetype(i)) = chempot_phase(1:gl%ncomp,phasetype(i))
            if (gl%zero_comp) call revert_zero_vector(gl,chempot_phase(:,phasetype(i)))

            lnfug_phase(gl%mapping(1:gl%ncomp),phasetype(i)) = lnfug_phase(1:gl%ncomp,phasetype(i))
            if (gl%zero_comp) call revert_zero_vector(gl,lnfug_phase(:,phasetype(i)))

        end if

    end do


    if(gl%seawater) then
        chempot = chempot_phase
        call seawater_remap(gl, fluids, moles, x_phase, chempot, phasetype)
        if (gl%zero_comp) call revert_zero_vector(gl,x_phase(:,phasetype(2)))
        if (gl%zero_comp) call revert_zero_vector(gl,x_phase(:,phasetype(3)))
        chempot_phase = chempot
    elseif(gl%el_present) then
        chempot = chempot_phase
        call el_remap(gl, fluids, moles, eos_indicator, x_phase, chempot, phasetype)
        chempot_phase = chempot
        molesorig = moles
    endif


    input=gl%inptorig

    gl%molfractions = molesorig         !be aware of molar / specific composition  and phase fractions ...

    if (gl%zero_comp) call revert_zero_inpt(gl, fluids, moles, eos_indicator)
#IF DEFINED(MAKE_SAFEARR)
    char_30_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=char_30_allo)
    deallocate(char_30_allo)

    char_4_allo = phase_text
    call chararray_to_safearray(phase_text_arg,4, FORTRAN_char_vektor=char_4_allo)
    deallocate(char_4_allo)

    char_30_arr_allo = prop_name_unit
    call chararray_to_safearray(prop_name_unit_arg,30, FORTRAN_char_array=char_30_arr_allo)
    deallocate(char_30_arr_allo)
#ELIF DEFINED(MAKE_MATLAB)

#ELSE
    fluids_arg = fluids
    prop_name_unit_arg = prop_name_unit
    phase_text_arg = phase_text
#ENDIF



    end subroutine MAKE_FUNC_NAME(FLASH3)

    subroutine MAKE_FUNC_NAME(HENRY_EOS) (Temp, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, H12, H21, errorflag, gl_handle)
    !-------------------------------------------------------------------------------
    !Subroutine for the calculation of the Henry constants of fluid 1 in fluid 2 H12
    !and fluid 2 in fluid 1 (H21) at given temperature:
    !H12 = lim(x1 -> 0) phi1_L * ps,2
    !H21 = lim(x2 -> 0) phi2_L * ps,1
    !The calculation is restricted to binary mixtures
    !Andreas Jäger, March 2017
    !-------------------------------------------------------------------------------
    !##########################################################################################
#define LOCAL_FUNC_NAME() HENRY_EOS
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################


    implicit none


#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    !define input/outpit variables
    double precision :: Temp
    character (30), dimension(30) :: fluids
    double precision, dimension (30) :: moles
    character (255) :: path
    integer, dimension (30) :: EOS_indicator
    integer :: MIX_indicator
    double precision:: H12, H21

    !Variables for setup
    double precision :: prop1, prop2        !Dummy variables
    integer :: errorflag, i
    integer :: unitin !dummy variable for control_fluids
    character (12) :: input

    logical:: H12_calc, H21_calc

    !Variables for the calculation of the pure component vapor pressure
    double precision :: press
    double precision :: rhovap_est, rholiq_est   ![mol/m³]
    integer :: iFlash, nrsubst
    integer :: iter

    !Variables for the calculation of the fugacity coefficient of the infinitly diluted component in the solvent
    double precision:: dens_liq
    double precision, dimension(30):: fugcoef_mix

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    !Catch errors in setup
    if (errorflag .ne. 0) then
        H12 = errorflag
        H21 = errorflag
        return
    end if
    H12_calc = .false.
    H12_calc = .false.
    H12 = 0.D0
    H21 = 0.D0

    !call setup
    errorflag = 0
    input = 'tp'    !Dummy
    prop1 = Temp
    prop2 = 1.0     !Dummy
    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    if(gl%seawater .or. gl%el_present) then
        errorflag = -12800
    end if

    !Catch errors in setup
    if (errorflag .ne. 0) then
        H12 = errorflag
        H21 = errorflag
        return
    end if

    !Calculation only possible for binary mixtures, throw error in other cases
    if (gl%ncomp .ne. 2) then
        errorflag = -5249
        H12 = errorflag
        H21 = errorflag
        return
    end if

    !Check which of the Henry constants can be calculated. In order to be able to calculate a Henry constant, the temperature of the solvent needs to be subcritical but higher than the triple temperature.
    If ((Temp < gl%tc(2)) .and. (Temp > gl%ttp(2))) then
        H12_calc = .true.
    else
        H12 = -4409
    end if

    If ((Temp < gl%tc(1)) .and. (Temp > gl%ttp(1))) then
        H21_calc = .true.
    else
        H21 = -4409
    end if

    !If no Henry constant can be calculated, quit with error
    If ((H12_calc .eqv. .false.) .and. (H21_calc .eqv. .false.)) then
        errorflag = -4409
        return
    end if

    if (H12_calc) then

        !Set composition to pure component 2
        gl%molfractions(1) = 0.D0
        gl%molfractions(2) = 1.D0
        call reduced_parameters_calc(gl,Temp)

        !Calculate vapor pressure of component 2
        rhovap_est = 0.D0
        rholiq_est = 0.D0
        iFlash = 1
        errorflag = 0
        nrsubst = 2
        press = 0.d0
        call Flash_Pure_PhaseBoundary (gl,press, Temp, rhovap_est, rholiq_est, iFlash, errorflag, iter, nrsubst)
        if (errorflag .ne. 0) then
            H12 = errorflag
            gl%molfractions = moles
            call reduced_parameters_calc(gl,Temp)
            return
        end if

        !Calculate the fugacity coefficient of the infinitely diluted component in the solvent
        dens_liq = rholiq_est   !Density is the density of the saturated liquid of component 2
        call FUGCO_CALC_MIX(gl,Temp, dens_liq, fugcoef_mix)
        H12 = fugcoef_mix(1) * press

    end if

    if (H21_calc) then

        !Set composition to pure component 1
        gl%molfractions(1) = 1.D0
        gl%molfractions(2) = 0.D0
        call reduced_parameters_calc(gl,Temp)

        !Calculate vapor pressure of component 1
        rhovap_est = 0.D0
        rholiq_est = 0.D0
        iFlash = 1
        errorflag = 0
        nrsubst = 1
        press = 0.d0
        call Flash_Pure_PhaseBoundary (gl,press, Temp, rhovap_est, rholiq_est, iFlash, errorflag, iter, nrsubst)
        if (errorflag .ne. 0) then
            H21 = errorflag
            gl%molfractions = moles
            call reduced_parameters_calc(gl,Temp)
            return
        end if

        !Calculate the fugacity coefficient of the infinitely diluted component in the solvent
        dens_liq = rholiq_est   !Density is the density of the saturated liquid of component 1
        call FUGCO_CALC_MIX(gl,Temp, dens_liq, fugcoef_mix)
        H21 = fugcoef_mix(2) * press

    end if

    gl%molfractions = moles
    call reduced_parameters_calc(gl,Temp)
#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(HENRY_EOS)


    subroutine MAKE_FUNC_NAME(GAMMATF_EOS) (input_arg, prop1_arg, prop2_arg, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, unitdefinition_arg, GAMMATF, errorflag, gl_handle)
    !subroutine for the calculation of the thermodynamic factor
    ! according to Taylor and Kooijman (1991)
    !Output: GAMMATF as double precision, dimension(30,30)
    !##########################################################################################
#define LOCAL_FUNC_NAME() GAMMATF_EOS
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################



    implicit none

    MAKE_ARG_CHAR(12), intent(in) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    !define input variables
    character (12) :: input
    character(20) :: unitdefinition
    double precision:: prop1, prop2, prop1_arg, prop2_arg
    character (30), dimension(30) :: fluids
    double precision, dimension(30), intent(inout) :: moles
    integer, dimension(30), intent(inout) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin
    character (255) :: path

    double precision, dimension(30,30), intent(out):: GAMMATF
    double precision, dimension(30,30):: temp

    !define variables for calculating
    double precision :: t, d, p, h, s
    double precision :: dvap
    double precision :: dliq
    double precision :: propvap
    double precision :: propliq
    double precision :: x_liq(30)
    double precision :: x_vap(30)


    integer :: errorflag
    integer :: nrsubst, i

    double precision:: rho(5)           ! vector containing the densities of all phases
    double precision:: x_Phase(30,5)    ! vector conaining the compositions of all phases
    double precision:: vapfrac             ! molar vapor fraction
    integer:: nrofphases                ! at this point: only 1 or 2 implemented
    !Indicate which phases are present
    integer:: phasetype(5)              !phasetype contains the phase indicator number
    !E.g.: 2 phases are present: liquid and liquid equilibrium
    !-- >  nrofphases = 2
    !-- >  phasetype(1) = 2 (light liquid)
    !-- >  phasetype(2) = 3 (heavy liquid)

    double precision, dimension(5) :: phasefrac
    double precision, dimension(5) :: prop_phase

    double precision:: d_phase
    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(input,12)
    STRING_TO_F(unitdefinition,20)

    !Preprocessor definition end
    !##########################################################################################

    prop1 = prop1_arg
    prop2 = prop2_arg

    !input to lower case
    call uppertolower_char(input, len(input))

    unitin = get_unitin(unitdefinition)
    if(unitin < 0) then
        errorflag = unitin
        return
    end if

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    !Catch errors in setup
    if (errorflag .ne. 0) then
        GAMMATF = errorflag
        return
    end if

    gl%calc_ref = .false.  ! no need calculate reference state
    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property

    !call setup
    errorflag = 0

    call uppertolower_char(unitdefinition, len(unitdefinition))

    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    if(gl%seawater .or. gl%el_present) then
        errorflag = -12800
    end if

    !Catch errors in setup
    if (errorflag .ne. 0) then
        GAMMATF = errorflag
        return
    end if

    call reduced_parameters_calc(gl,300.d0)

    if (gl%ncomp .gt. 1) then
        call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles, rho, x_Phase, phasetype, &
            & phasefrac, nrofphases, nrsubst, errorflag)
    else
        GAMMATF = -5248.d0   !property only available for mixtures
        errorflag = -5248
        return
    end if

    if (errorflag .ne. 0) then
        GAMMATF = errorflag
        return
    end if

    if (nrofphases > 1) then
        GAMMATF = -6666.d0
        return
    end if

    if (phasetype(1) < 4) then  !fluid phase
        d_phase = rho(phasetype(1))
    else
        GAMMATF = -9904.d0
        return
    end if

    Call GAMMATF_CALC(gl,T, d_phase, GAMMATF)

    if (gl%zero_comp)then
        call revert_zero_inpt(gl, fluids, moles, eos_indicator)
        temp(1:gl%ncomp,1:gl%ncomp-1)  = GAMMATF(1:gl%ncomp,1:gl%ncomp-1)
        GAMMATF(1:gl%ncomp,1:gl%ncomp-1) = 0.d0
        GAMMATF(gl%comp_map,gl%comp_map(1:gl%ncomp-1)) = temp(1:gl%ncomp,1:gl%ncomp-1)

    endif


#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(GAMMATF_EOS)

    subroutine MAKE_FUNC_NAME(FUGCOEFF_EOS) (input_arg, prop1_arg, prop2_arg, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, FUGCOEFF, errorflag, gl_handle)
    !subroutine for the calculation of the fugacity coefficients
    !Output: FUGCOEFF as double precision, dimension(30,30)
    !##########################################################################################
#define LOCAL_FUNC_NAME() FUGCOEFF_EOS
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################


    implicit none

    MAKE_ARG_CHAR(12), intent(in) ::  input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    !define input variables
    character (12) :: input
    double precision:: prop1, prop2, prop1_arg, prop2_arg
    character (30), dimension(30) :: fluids
    double precision, dimension(30), intent(inout) :: moles
    integer, dimension(30), intent(inout) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin ! dummy variable for control_fluids
    character (255) :: path

    double precision, dimension(30,30), intent(out):: FUGCOEFF

    !define variables for calculating
    double precision :: t, d, p, h, s
    double precision :: dvap
    double precision :: dliq
    double precision :: propvap
    double precision :: propliq
    double precision :: x_liq(30)
    double precision :: x_vap(30)


    integer :: errorflag
    integer :: nrsubst, i, j

    double precision:: rho(5)           ! vector containing the densities of all phases
    double precision:: x_Phase(30,5)    ! vector conaining the compositions of all phases
    double precision:: vapfrac             ! molar vapor fraction
    integer:: nrofphases                ! at this point: only 1 or 2 implemented
    !Indicate which phases are present
    integer:: phasetype(5)              !phasetype contains the phase indicator number
    !E.g.: 2 phases are present: liquid and liquid equilibrium
    !-- >  nrofphases = 2
    !-- >  phasetype(1) = 2 (light liquid)
    !-- >  phasetype(2) = 3 (heavy liquid)

    double precision, dimension(5) :: phasefrac
    double precision, dimension(5) :: prop_phase
    double precision, dimension(30) :: fugcoef_mix

    double precision:: d_phase
    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(input,12)

    !Preprocessor definition end
    !##########################################################################################

    prop1 = prop1_arg
    prop2 = prop2_arg

    unitin = 1

    !input to lower case
    call uppertolower_char(input, len(input))

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    !Catch errors in setup
    if (errorflag .ne. 0) then
        FUGCOEFF = errorflag
        return
    end if

    gl%calc_ref = .false.  ! no need calculate reference state
    gl%transport = 0       ! needed to check the range of validity for transport properties; 0 for every other property

    !call setup
    errorflag = 0

    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    if(gl%seawater .or. gl%el_present) then
        errorflag = -12800
    end if

    !Catch errors in setup
    if (errorflag .ne. 0) then
        FUGCOEFF = errorflag
        return
    end if

    call reduced_parameters_calc(gl,300.d0)


    call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles, rho, x_Phase, phasetype, &
        & phasefrac, nrofphases, nrsubst, errorflag)


    if (errorflag .ne. 0) then
        FUGCOEFF = errorflag
        return
    end if


    FUGCOEFF = 0.d0

    if (gl%ncomp > 1.d0) then
        do i = 1, nrofphases
            d_phase = rho(phasetype(i))

            if (rho(phasetype(i)) > 0.d0) then
                gl%molfractions = x_phase(:,phasetype(i))
                call reduced_parameters_calc(gl, 300.d0)
                call FUGCO_CALC_MIX(gl,T,d_phase, fugcoef_mix)
                FUGCOEFF (phasetype(i),1:gl%ncomp) = fugcoef_mix(1:gl%ncomp)

                if (gl%zero_comp) then
                    FUGCOEFF (phasetype(i),1:gl%ncomp) = 0.d0
                    FUGCOEFF (phasetype(i),gl%comp_map) = fugcoef_mix(1:gl%ncomp)
                endif

            elseif (rho(phasetype(i)) < 0.d0) then
                FUGCOEFF (i,:) = rho(phasetype(i))
            end if

        end do

    else

        do i = 1, nrofphases
            d_phase = rho(phasetype(i))

            if (rho(phasetype(i)) > 0.d0) then
                FUGCOEFF (phasetype(i),1) = FUGCOPURE_CALC (gl, T, d_phase, nrsubst)
            elseif (rho(phasetype(i)) < 0.d0) then
                FUGCOEFF (i,1) = rho(phasetype(i))
            end if


        end do
    end if

    if (gl%zero_comp) call revert_zero_inpt(gl, fluids, moles, eos_indicator)

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(FUGCOEFF_EOS)



    !------------------------------------------------------------------------------------------
    ! INTERFACE CALL FOR PROP UNIT FUNCTION   - FROM GIVEN UNIT AND TYPE OF PROPERTY
    ! THE CORRECT UNIT IS RETUNED
    subroutine MAKE_FUNC_NAME(PROPUNIT) (unitdefinition_arg, unittype_arg, prop, errorflag)
    !##########################################################################################
#define LOCAL_FUNC_NAME() PROPUNIT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    use prop_unit_m

    implicit none

    MAKE_ARG_CHAR(12), intent(in) :: unittype_arg
    MAKE_ARG_CHAR(20), intent(in) :: unitdefinition_arg

    !define input variables
    character(20), intent(out) :: prop
    character(12) :: unittype
    character(20) :: unitdefinition
    integer :: errorflag, unitinput

    !##########################################################################################
    !Preprocessor definition start
    STRING_TO_F(unittype,12)
    STRING_TO_F(unitdefinition,20)
    !Preprocessor definition end
    !##########################################################################################

    prop = PROP_UNIT_INTERFACE(unitdefinition, unittype , 20,  errorflag)

    end subroutine MAKE_FUNC_NAME(PROPUNIT)
    ! INTERFACE CALL FOR PROP UNIT FUNCTION
    !------------------------------------------------------------------------------------------




    subroutine MAKE_FUNC_NAME(PTDIAG_OUT) (env_pv, fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, p_spec, T_spec,t_pts_out, p_pts_out, rholiq_pts_out, rhovap_pts_out, &
        & pointID_pts_out, x_pts_out, fileout_arg, errorflag, gl_handle)
    !**************************************************************************
    ! Interface function for plotting a pt-diagram for mixtures
    !##########################################################################################
#define LOCAL_FUNC_NAME() PTDIAG_OUT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################



    implicit none

#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) :: path_arg
    MAKE_ARG_CHAR(255), intent(in) :: fileout_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    !toggle to set whether pressure or volumebased phaseenvelope calculation is used
    integer, intent(in) :: env_pv !1: pressure based, 2: volume based phaseenvelope

    !!! if no pressure / temperature is specified it has to be set to zero !!!
    double precision, intent(inout) :: p_spec, T_spec                           ! specified pressure / temperature
    integer, intent(out) :: errorflag                             ! error handling
    character(255) :: fileout    ! optional path for output file
    integer, dimension(30):: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin ! dummy variable for control_fluids

    !Output, maximum: 400 pts
    double precision, dimension(400), intent(out):: t_pts_out, p_pts_out, rholiq_pts_out, rhovap_pts_out
    integer, dimension(400), intent(out):: pointID_pts_out
    double precision, dimension(400, 30), intent(out):: x_pts_out

    double precision, dimension(6):: pt_return                  ! return value(s) (temp. or press) at the specified pressure/temperature
    double precision, dimension(6,2):: rho_return               ! rho_liq (i,1) and rho_vap (i,2) at the specified pressure/temperature
    double precision, dimension(30,6):: x_return                ! return values for the compositions of the emerging phase at specified pressure/temperature
    integer:: points_found, trunc_fac, i, k, upper_limit_npoints
    double precision :: uplimnp_dbl


    !-------------------------------------------------------------------
    !Initialize
    character (12) :: input
    double precision :: prop1, prop2
    character (30), dimension(30) :: fluids
    double precision, dimension(30) :: moles
    character (255) :: path
    double precision, dimension(400):: p_points_array, T_points_array, rhovap_points, rholiq_points
    integer:: points
    character (255):: filepure
    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo

#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(fileout,255)

    !Preprocessor definition end
    !##########################################################################################
    unitin = 1
    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if(errorflag /= 0) then
        t_pts_out = errorflag
        p_pts_out = errorflag
        rholiq_pts_out = errorflag
        rhovap_pts_out = errorflag
        pointID_pts_out = errorflag
        x_pts_out = errorflag
        return
    end if

    !Dummy values for input, Temp and press
    input = 'tp'
    prop1 = 300.D0
    prop2 = 0.1D0

    !call setup
    errorflag = 0

    call setup (gl,input, prop1, prop2, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    if(gl%seawater .or. gl%el_present) then
        errorflag = -12800
    end if

    !------------------------------------------------------------------
    if (errorflag == 0) then
        t_pts_out = 0.D0
        p_pts_out = 0.D0
        rholiq_pts_out = 0.D0
        rhovap_pts_out = 0.D0
        pointID_pts_out = 0
        x_pts_out = 0.D0
        filepure=''
    else
        t_pts_out = errorflag
        p_pts_out = errorflag
        rholiq_pts_out = errorflag
        rhovap_pts_out = errorflag
        pointID_pts_out = errorflag
        x_pts_out = errorflag
        return
    end if

    if (gl%ncomp == 1) then
        call SATPLOT(gl,p_spec, T_spec, p_points_array, T_points_array, rhovap_points, rholiq_points, points, fileout, errorflag)
        if (errorflag == 0) then
            t_pts_out = T_points_array
            p_pts_out = p_points_array
            rholiq_pts_out = rholiq_points
            rhovap_pts_out = rhovap_points
            pointID_pts_out(1:200) = gl%pointID(1:200)
        else
            t_pts_out(1:points) = T_points_array(1:points)
            t_pts_out(points+1:) = errorflag
            p_pts_out(1:points) = p_points_array(1:points)
            p_pts_out(points+1:) = errorflag
            rholiq_pts_out(1:points) = rholiq_points(1:points)
            rholiq_pts_out(points+1:) = errorflag
            rhovap_pts_out(1:points) = rhovap_points(1:points)
            rhovap_pts_out(points+1:) = errorflag
            pointID_pts_out(1:points) = gl%pointID(1:points)
            pointID_pts_out(points+1:) = errorflag
        endif
        return
    else
        if (env_pv == 1) then
            upper_limit_npoints = 200
            call ptdiag(gl,moles, p_spec, T_spec, pt_return, rho_return, x_return, points_found, errorflag)
        elseif (env_pv == 2) then
            upper_limit_npoints = 400
            call ptdiag_vbased(gl,moles, p_spec, T_spec, pt_return, rho_return, x_return, points_found, errorflag)
        endif
        uplimnp_dbl = upper_limit_npoints
    end if

    !Leave some space in the return array for specified and special points like critical pts, cricondenbar, cricondentherm etc.
    if (gl%phasenv_pts > 0) then
        if (gl%phasenv_pts > (upper_limit_npoints - 15)) then
            trunc_fac = ceiling(gl%phasenv_pts / (uplimnp_dbl - 15.d0))
            k = 1
            t_pts_out(k) = gl%T_pts(1)
            p_pts_out(k) = gl%p_pts(1)
            rholiq_pts_out(k) = gl%rholiq_pts(1)
            rhovap_pts_out(k) = gl%rhovap_pts(1)
            pointID_pts_out(k) = gl%pointID(1)
            x_pts_out(k,:) = gl%x_pts(1,:)
            k = k + 1
            Do i = 1, gl%phasenv_pts
                if(mod(i,trunc_fac) == 0) then
                    t_pts_out(k) = gl%T_pts(i)
                    p_pts_out(k) = gl%p_pts(i)
                    rholiq_pts_out(k) = gl%rholiq_pts(i)
                    rhovap_pts_out(k) = gl%rhovap_pts(i)
                    pointID_pts_out(k) = gl%pointID(i)
                    x_pts_out(k,:) = gl%x_pts(i,:)
                    k = k + 1
                End if
                if (k == upper_limit_npoints) return
                if(gl%pointID(i) /= 0) then
                    if (gl%pointID(i) /= pointID_pts_out(k-1)) then
                        t_pts_out(k) = gl%T_pts(i)
                        p_pts_out(k) = gl%p_pts(i)
                        rholiq_pts_out(k) = gl%rholiq_pts(i)
                        rhovap_pts_out(k) = gl%rhovap_pts(i)
                        pointID_pts_out(k) = gl%pointID(i)
                        x_pts_out(k,:) = gl%x_pts(i,:)
                        k = k + 1
                    endif
                End if
                if (k == upper_limit_npoints) return
            End do
        else
            t_pts_out = gl%T_pts(1:upper_limit_npoints)
            p_pts_out = gl%p_pts(1:upper_limit_npoints)
            rholiq_pts_out = gl%rholiq_pts(1:upper_limit_npoints)
            rhovap_pts_out = gl%rhovap_pts(1:upper_limit_npoints)
            pointID_pts_out = gl%pointID(1:upper_limit_npoints)
            x_pts_out = gl%x_pts(1:upper_limit_npoints,:)
        End if
    else
        t_pts_out = errorflag
        p_pts_out = errorflag
        rholiq_pts_out = errorflag
        rhovap_pts_out = errorflag
        pointID_pts_out = errorflag
        x_pts_out = errorflag
    End if

    if (gl%zero_comp) call revert_zero_inpt(gl, fluids, moles, eos_indicator)

    do i=1, 400
        if (t_pts_out(i)==0)then
            exit
        end if

        if (gl%zero_comp) call revert_zero_vector(gl, x_pts_out(i,:))
    end do

#IF DEFINED(_DEBUG)  
    ! output file format
1000 format(f10.5, f10.4, f10.3, f10.3)
1001 format(D15.9, f10.4, 5x, f10.8, 5x, D15.9)

    if (trim(fileout) /= '') then
        open(unit = 13,file=fileout, status='unknown', action='write', iostat=errorflag)
        if (errorflag /= 0) return
        write(13,*)'!---------------------------------------------------------------------------------'
        write(13,*)'! P-T DIAGRAM DATA FILE'
        write(13,*)'!'
        write(13,*)'!---------------------------------------------------------------------------------'
        write(13,*)'!'
        write(13,*)'! p/MPa    ','T/K       ','   dl/mol/l ', 'dv/mol/l'
        do i = 1, upper_limit_npoints
            write(13,1000) p_pts_out(i), t_pts_out(i), rholiq_pts_out(i)/1000.d0, rhovap_pts_out(i)/1000.d0
        end do
        close(13)
    end if
#ENDIF      

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(PTDIAG_OUT)
    !**************************************************************************



    subroutine MAKE_FUNC_NAME(PTXDIAG_OUT) (input_arg, prop, fluids_arg, EOS_indicator, MIX_indicator, path_arg, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, &
        & points, fileout_arg, errorflag, gl_handle)
    !--------------------------------------------------------------------------------
    !    This subroutine is for interfacing pxdiag and txdiag routines for dlls calls
    !--------------------------------------------------------------------------------
    ! S.Hielscher und S.Herrig, June 2016, revised Nov 2016
    !##########################################################################################
#define LOCAL_FUNC_NAME() PTXDIAG_OUT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

    MAKE_ARG_CHAR(12), intent(in) :: input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) :: path_arg
    MAKE_ARG_CHAR(255), intent(in) :: fileout_arg



    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    !--------------------------------------------------------------------------------
    integer, intent(out):: points, errorflag                ! number of calculated points, error code
    integer :: points_copy, errorflag_copy
    integer, parameter:: maxi = 300 ! maximum number of calculated points, lengt of the return vectors!
    double precision:: prop     ! specified temperature for the p-x diagram
    double precision, dimension(maxi), intent(out):: T_points_array, p_points_array, rhovap_points, rholiq_points    ! return vectors of the calculated points
    double precision, intent(out):: x_points(maxi,4)   ! this array is filled according to:
    ! x_points(i,1) = x_vap(1), x_points(i,2) = x_vap(2)
    ! x_points(i,3) = x_liq(1), x_points(i,4) = x_liq(2)
    double precision, dimension(maxi):: T_points_copy, p_points_copy, rhovap_points_copy, rholiq_points_copy    ! return vectors of the calculated points
    double precision :: x_points_copy(maxi,4)   ! this array is filled according to:
    ! x_points(i,1) = x_vap(1), x_points(i,2) = x_vap(2)
    ! x_points(i,3) = x_liq(1), x_points(i,4) = x_liq(2)
    double precision, dimension(30):: moles              ! composition of the system

    character(12) :: input
    character(255) :: fileout    ! optional path for output file

    character (30), dimension(30) :: fluids
    integer, dimension(30) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin ! dummy variable for control_fluids
    character (255) :: path
    !switchfluids = 1: fluid order was switched -> this has to be undone by swapping point order and molefractions x1 -> x2, x2 -> x1
    !switchfluids = 2: former azeotropic mixture, splited in two vle regions (co2-ethane T > 290 K)
    !swtichfluids = 3: Mostly relevant for open VLE regions -> start with component with smaller vapor pressure or higher saturation temperature,
    !                  because this component will most likely be attached to y axis while the other component is detached from y axis
    integer :: i,j, switchfluids, switchfluids_copy, switchfluids_count
    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(input, 12)
    STRING_TO_F(path, 255)
    STRING_TO_F(fileout,255)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1

    moles = 0.d0
    j=0

    !check if 2 components are present and set dummy mole numbers
    do i=1,30
        if (trim(fluids(i)) /= '') then
            moles(i) = 0.5d0
            j=j+1
            if (j>2)then
                errorflag = -5249
                return
            end if
        end if
    end do

    if (j<2)then
        errorflag = -5249
        return
    end if


    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if(errorflag /= 0) return

    call uppertolower_char(input,12 )


    errorflag = 0
    switchfluids = 0 !fluid order was not changed
    switchfluids_copy = 0
    switchfluids_count = 1
    !delete semicolon at the end of the string

    !if (fluids(len(trim(fluids)):len(trim(fluids))) == ";")  fluids = fluids(1:len(trim(fluids))-1)

    if ((trim(input) == 'tvap').or.(trim(input) == 'tliq')) then
        call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
        !catch very low temperatures
        if ((prop < gl%ttp(1)).and.(prop < gl%ttp(2))) then
            errorflag = -5531
            return
        endif
        if (errorflag == 0) then
            !check if given temperature is below both critical temperatures
            if ((prop > gl%tc(1)).and.(prop > gl%tc(2))) then
                errorflag = -5530
                return
                !check if given temperature is below critical temperature of first fluid
                !if input temperature is above tc(1) switch the fluid order, because the calculation starts always with x(1) = 1 side
                !this has to be undone after the calculations are finished
            elseif (prop > gl%tc(1)) then
                fluids(1:2) = fluids(2:1:-1)
                call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
                switchfluids = 1
                switchfluids_copy = switchfluids
                switchfluids_count = switchfluids_count * -1
            endif

            points = 1
            call pxdiag(gl,prop, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)

            !!
            if (switchfluids == 3) then
                fluids(1:2) = fluids(2:1:-1)
                call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

                switchfluids = 1

                switchfluids_copy = switchfluids
                switchfluids_count = switchfluids_count * -1

                points = 1
                call pxdiag(gl,prop, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)


            endif
            !!

            !former azeotropic mixture has split into two vle regions, the second one will be calculated next
            if (switchfluids == 2) then
                p_points_copy = p_points_array
                T_points_copy = T_points_array
                x_points_copy = x_points
                rhovap_points_copy = rhovap_points
                rholiq_points_copy = rholiq_points
                points_copy = points
                fluids(1:2) = fluids(2:1:-1)

                switchfluids_count = switchfluids_count * -1

                call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
                call pxdiag(gl,prop, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)
                switchfluids = 1

                if (x_points(points,1) > x_points_copy(points_copy, 2))then !Check if it is really a splitted azeotrop
                    switchfluids = 2
                    !the first side has to flip so that both sides go for x2 from 0 to 1
                    if (switchfluids_count<0)then

                        p_points_array(points+1) = -1.d0

                        p_points_array(points+2:points+points_copy+1) = p_points_copy(points_copy:1:-1)
                        T_points_array(points+2:points+points_copy+1) = T_points_copy(points_copy:1:-1)
                        rhovap_points(points+2:points+points_copy+1) = rhovap_points_copy(points_copy:1:-1)
                        rholiq_points(points+2:points+points_copy+1) = rholiq_points_copy(points_copy:1:-1)
                        x_points(points+2:points+points_copy+1, 2) = x_points_copy(points_copy:1:-1, 1)
                        x_points(points+2:points+points_copy+1, 1) = x_points_copy(points_copy:1:-1, 2)
                        x_points(points+2:points+points_copy+1, 4) = x_points_copy(points_copy:1:-1, 3)
                        x_points(points+2:points+points_copy+1, 3) = x_points_copy(points_copy:1:-1, 4)

                    else
                        p_points_copy(points_copy+1) = -1.d0

                        p_points_copy(points_copy+2:points_copy+1+points) = p_points_array(points:1:-1)
                        T_points_copy(points_copy+2:points_copy+1+points) = T_points_array(points:1:-1)
                        rhovap_points_copy(points_copy+2:points_copy+1+points) = rhovap_points(points:1:-1)
                        rholiq_points_copy(points_copy+2:points_copy+1+points) = rholiq_points(points:1:-1)
                        x_points_copy(points_copy+2:points_copy+1+points, 1) = x_points(points:1:-1, 2)
                        x_points_copy(points_copy+2:points_copy+1+points, 2) = x_points(points:1:-1, 1)
                        x_points_copy(points_copy+2:points_copy+1+points, 3) = x_points(points:1:-1, 4)
                        x_points_copy(points_copy+2:points_copy+1+points, 4) = x_points(points:1:-1, 3)

                        p_points_array = p_points_copy
                        T_points_array = T_points_copy
                        x_points = x_points_copy
                        rhovap_points = rhovap_points_copy
                        rholiq_points = rholiq_points_copy
                        switchfluids_count = switchfluids_count * -1
                    endif

                    points = points + points_copy + 1

                else !if not splitted azeotrop but phase envelope was calculated from both sides and overlaps

                    !the first side has to flip so that both sides go for x2 from 0 to 1
                    if (switchfluids_count<0)then

                        !p_points_array(points+2:points+points_copy+1) = p_points_copy(points_copy:1:-1)
                        !T_points_array(points+2:points+points_copy+1) = T_points_copy(points_copy:1:-1)
                        !rhovap_points(points+2:points+points_copy+1) = rhovap_points_copy(points_copy:1:-1)
                        !rholiq_points(points+2:points+points_copy+1) = rholiq_points_copy(points_copy:1:-1)
                        !x_points(points+2:points+points_copy+1, 2) = x_points_copy(points_copy:1:-1, 1)
                        !x_points(points+2:points+points_copy+1, 1) = x_points_copy(points_copy:1:-1, 2)
                        !x_points(points+2:points+points_copy+1, 4) = x_points_copy(points_copy:1:-1, 3)
                        !x_points(points+2:points+points_copy+1, 3) = x_points_copy(points_copy:1:-1, 4)

                        j=1
                        do i=1, points_copy
                            if (p_points_array(points)>p_points_copy(points_copy+1-i))then
                                p_points_array(points+j) = p_points_copy(points_copy+1-i)
                                T_points_array(points+j) = T_points_copy(points_copy+1-i)
                                rhovap_points(points+j) = rhovap_points_copy(points_copy+1-i)
                                rholiq_points(points+j) = rholiq_points_copy(points_copy+1-i)
                                x_points(points+j,2) = x_points_copy(points_copy+1-i,1)
                                x_points(points+j,1) = x_points_copy(points_copy+1-i,2)
                                x_points(points+j,4) = x_points_copy(points_copy+1-i,3)
                                x_points(points+j,3) = x_points_copy(points_copy+1-i,4)

                                j=j+1
                            end if
                        end do
                        points_copy=j-1

                    else

                        !p_points_copy(points_copy+2:points_copy+1+points) = p_points_array(points:1:-1)
                        !T_points_copy(points_copy+2:points_copy+1+points) = T_points_array(points:1:-1)
                        !rhovap_points_copy(points_copy+2:points_copy+1+points) = rhovap_points(points:1:-1)
                        !rholiq_points_copy(points_copy+2:points_copy+1+points) = rholiq_points(points:1:-1)
                        !x_points_copy(points_copy+2:points_copy+1+points, 1) = x_points(points:1:-1, 2)
                        !x_points_copy(points_copy+2:points_copy+1+points, 2) = x_points(points:1:-1, 1)
                        !x_points_copy(points_copy+2:points_copy+1+points, 3) = x_points(points:1:-1, 4)
                        !x_points_copy(points_copy+2:points_copy+1+points, 4) = x_points(points:1:-1, 3)

                        j=1
                        do i=1, points
                            if (p_points_copy(points_copy) < p_points_array(points+1-i))then
                                p_points_copy(points_copy+j) = p_points_array(points+1-i)
                                T_points_copy(points_copy+j) = T_points_array(points+1-i)
                                rhovap_points_copy(points_copy+j) = rhovap_points(points+1-i)
                                rholiq_points_copy(points_copy+j) = rholiq_points(points+1-i)
                                x_points_copy(points_copy+j,1) = x_points(points+1-i,2)
                                x_points_copy(points_copy+j,2) = x_points(points+1-i,1)
                                x_points_copy(points_copy+j,3) = x_points(points+1-i,4)
                                x_points_copy(points_copy+j,4) = x_points(points+1-i,3)

                                j=j+1
                            end if
                        end do

                        points=j-1
                        p_points_array = p_points_copy
                        T_points_array = T_points_copy
                        x_points = x_points_copy
                        rhovap_points = rhovap_points_copy
                        rholiq_points = rholiq_points_copy
                        switchfluids_count = switchfluids_count * -1
                    endif

                    points = points + points_copy

                end if

                !switchfluids = switchfluids_copy

                !elseif (switchfluids == 3) then
                !    fluids(1:2) = fluids(2:1:-1)
                !    call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
                !    switchfluids = 1
                !    switchfluids_copy = switchfluids
                !    call pxdiag(gl,prop, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)
            endif

            !if (switchfluids /= 2)then
            if (switchfluids_count < 0)then
                switchfluids = 1
            else
                switchfluids = 0
            endif
            !endif
        else
            return
        endif

    elseif ((trim(input) == 'pvap').or.(trim(input) == 'pliq')) then
        call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
        if (errorflag == 0) then
            !  if ((prop > pc(1)).and.(prop > pc(2))) then
            !errorflag = -5530
            !elseif (prop > pc(1)) then
            !if the pressure of one component is above the critical pressure the calculations will be faster if they start
            !from the side of the undercritical component
            if ((prop > gl%pc(1)).and. (prop < gl%pc(2))) then
                fluids(1:2) = fluids(2:1:-1)
                call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
                switchfluids = 1
            endif
            call txdiag(gl,prop, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)
            !former azetropic mixtures has split into two heterogeneous regions
            if (switchfluids == 3) then
                fluids(1:2) = fluids(2:1:-1)
                call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
                switchfluids = 1
                switchfluids_copy = switchfluids
                call txdiag(gl,prop, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)
            endif
        else
            return
        endif
    else
        errorflag = -9955
    endif
    errorflag_copy = errorflag
    if (switchfluids /= 0) then
        fluids(1:2) = fluids(2:1:-1)
        call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
        !a(i, 10:1:-1)            ! row in reverse order
        p_points_array(1:points) = p_points_array(points:1:-1)
        T_points_array(1:points) = T_points_array(points:1:-1)
        rhovap_points(1:points) = rhovap_points(points:1:-1)
        rholiq_points(1:points) = rholiq_points(points:1:-1)
        if (switchfluids == 1) then
            x_points(1:points, 1:2) = x_points(points:1:-1, 2:1:-1)
            x_points(1:points, 3:4) = x_points(points:1:-1, 4:3:-1)
        elseif (switchfluids == 2) then
            x_points(1:points, 1:4) = x_points(points:1:-1, 1:4)
        endif
        errorflag = errorflag_copy
    endif
#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(PTXDIAG_OUT)

    subroutine MAKE_FUNC_NAME(TERNARY_DIAG_OUT) (prop1_arg, prop2_arg, fluids_arg, EOS_indicator, MIX_indicator, path_arg, x_points, rhovap_points_ter, rholiq_points_ter, &
        & points_ter, errorflag, gl_handle)

    !(prop1, prop2, fluids_arg, EOS_indicator, MIX_indicator, path_arg, x_points, rhovap_points_ter, rholiq_points_ter, &
    !& points_ter, fileout_arg, errorflag, gl_handle)
    !--------------------------------------------------------------------------------
    !    This subroutine is for calculation of ternary phase diagrams
    !--------------------------------------------------------------------------------
    ! T. Neumann June 2019
    !##########################################################################################
#define LOCAL_FUNC_NAME() TERNARY_DIAG_OUT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################


    implicit none

#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) :: path_arg
    !MAKE_ARG_CHAR(255), intent(in) :: fileout_arg



    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    !--------------------------------------------------------------------------------
    integer, intent(out):: errorflag                ! error code
    integer, dimension(3), intent(out):: points_ter !Array of number of calculated points
    integer :: points_copy, points
    integer,parameter:: maxi=300        !Iteration nbr, same as for ptx
    double precision:: prop1,prop2, prop1_arg, prop2_arg     ! specified temperature and pressure
    double precision, intent(out):: x_points(maxi,18), rhovap_points_ter(maxi,3), rholiq_points_ter(maxi,3)  ! return vectors of the calculated points for the ternary
    double precision, dimension(maxi):: T_points_array_bin, p_points_array_bin, p_points_copy_bin, rhovap_points_copy_bin, rholiq_points_copy_bin    ! return vectors of the calculated points for the binaries
    double precision :: x_points_bin_copy(maxi,4), moles_2ph(4,3),x_points_bin(maxi,4),x_points_flash(maxi,3),x_points_middle(maxi+1,3), rhovap_points(maxi), rholiq_points(maxi)  ! this array is filled according to:
    double precision, dimension(30):: moles, moles_bin              ! composition of the system
    character(12) :: input, input_bin
    character(255) :: fileout    ! optional path for output file

    character (30), dimension(30) :: fluids, fluids_bin
    integer, dimension(30) :: EOS_indicator, EOS_indicator_bin
    integer :: MIX_indicator, bin_test(3)
    integer :: unitin ! dummy variable for control_fluids
    character (255) :: path
    !switchfluids = 1: fluid order was switched -> this has to be undone by swapping point order and molefractions x1 -> x2, x2 -> x1
    !switchfluids = 2: former azeotropic mixture, splited in two vle regions (co2-ethane T > 290 K)
    !swtichfluids = 3: Mostly relevant for open VLE regions -> start with component with smaller vapor pressure or higher saturation temperature,
    !                  because this component will most likely be attached to y axis while the other component is detached from y axis
    integer :: i,j, switchfluids, switchfluids_copy,j1, nrofphases, nrsubst, phasetype(5),errorflag_copy
    double precision :: p, t, d, dvap, dliq, rho(5), x_phase(30,5), phasefrac(5), stepsize, abs_middle
    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    !STRING_TO_F(fileout,255)

    !Preprocessor definition end
    !##########################################################################################

    prop1 = prop1_arg
    prop2 = prop2_arg

    moles = 0.d0
    j=0

    !check if 3 components are present and set dummy mole numbers
    do i=1,30
        if (trim(fluids(i)) /= '') then
            moles(i) = 1.d0/3.d0
            j=j+1
            if (j>3)then
                errorflag = -5251
                return
            end if
        end if
    end do

    if (j<3)then
        errorflag = -5251
        return
    end if

    input='TP          '
    unitin = 1

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if(errorflag /= 0) return

    call uppertolower_char(input,12 )

    bin_test = 0
    errorflag = 0
    errorflag_copy = 1

    call setup (gl,input, prop1, prop2,fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)

    if(errorflag /= 0) then
        return
    end if

    !catch if not ternary inputs
    if( (trim(fluids(2))=="") .or. (trim(fluids(3))=="") .or. (EOS_indicator(2)==0) .or. (EOS_indicator(3)==0)) then
        errorflag = -9953
        return
    end if

    !catch very low temperatures
    if ((prop1 < gl%ttp(1)).and.(prop1 < gl%ttp(2)).and.(prop1 < gl%ttp(3))) then
        errorflag = -5531
        return
    end if

    !check if given temperature is below all critical temperatures
    if ((prop1 > gl%tc(1)).and.(prop1 > gl%tc(2)).and.(prop1 > gl%tc(3))) then
        errorflag = -5530
        return
    end if


    if ((prop1 < gl%tc(1)).or.(prop1 < gl%tc(2))) then
        bin_test(1) = 1
    end if
    if ((prop1 < gl%tc(1)).or.(prop1 < gl%tc(3))) then
        bin_test(2) = 1
    end if
    if ((prop1 < gl%tc(2)).or.(prop1 < gl%tc(3))) then
        bin_test(3) = 1
    end if


    if (errorflag == 0) then

        !check if given temperature is below critical temperature of first fluid
        !if input temperature is above tc(1) switch the fluid order, because the calculation starts always with x(1) = 1 side
        !this has to be undone after the calculations are finished

        moles_bin = 0.d0
        moles_2ph = 0.d0
        points_ter = 0
        x_points = 0.d0
        rhovap_points_ter = 0.d0
        rholiq_points_ter = 0.d0
        input_bin = "TVAP"

        !find binary two phase region for all three possible combinations by calculating the p,x diagrams at the corresponding temperature and searching for the pressure on the phase boundaries, take the middle between the two compositions to flash at the exact pressure
        do i=1,3

            moles_bin(1) = 0.5d0
            moles_bin(2) = 0.5d0
            switchfluids = 0
            switchfluids_copy = 0

            if (i==1) then
                if (bin_test(1)==1) then

                    fluids_bin = fluids
                    fluids_bin(3) = ""
                    EOS_indicator_bin = EOS_indicator
                    EOS_indicator_bin(3) = 0.d0

                    !new gl because changing from ternary to binary
                    call control_fluids(gl,input,fluids_bin,moles_bin,EOS_indicator_bin,unitin,gl_handle,errorflag)
                    if(errorflag /= 0) return

                    call setup (gl,input, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)

                    if (prop1>gl%tc(1)) then
                        fluids_bin(1:2) = fluids_bin(2:1:-1)
                        switchfluids = 1
                        switchfluids_copy = switchfluids
                        EOS_indicator_bin(1) = EOS_indicator(2)
                        EOS_indicator_bin(2) = EOS_indicator(1)

                    end if


                else
                    exit

                end if

            elseif (i==2) then

                if (bin_test(2)==1) then

                    fluids_bin = fluids
                    fluids_bin(2) = fluids(3)
                    fluids_bin(3) = ""
                    EOS_indicator_bin = EOS_indicator
                    EOS_indicator_bin(2) = EOS_indicator(3)
                    EOS_indicator_bin(3) = 0.d0

                    call setup (gl,input, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)

                    if (prop1>gl%tc(1)) then
                        fluids_bin(1:2) = fluids_bin(2:1:-1)
                        switchfluids = 1
                        switchfluids_copy = switchfluids
                        EOS_indicator_bin(1) = EOS_indicator(3)
                        EOS_indicator_bin(2) = EOS_indicator(1)
                    end if


                else
                    exit

                end if

            elseif (i==3) then
                if (bin_test(3)==1) then

                    fluids_bin = fluids
                    fluids_bin(1) = fluids(2)
                    fluids_bin(2) = fluids(3)
                    fluids_bin(3) = ""

                    EOS_indicator_bin = EOS_indicator
                    EOS_indicator_bin(1) = EOS_indicator(2)
                    EOS_indicator_bin(2) = EOS_indicator(3)
                    EOS_indicator_bin(3) = 0.d0

                    call setup (gl,input, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)

                    if (prop1>gl%tc(1)) then
                        fluids_bin(1:2) = fluids_bin(2:1:-1)
                        switchfluids = 1
                        switchfluids_copy = switchfluids
                        EOS_indicator_bin(1) = EOS_indicator(3)
                        EOS_indicator_bin(2) = EOS_indicator(2)
                    end if


                else
                    exit

                end if

            end if


            call setup (gl,input_bin, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)

points = 1
            call pxdiag(gl,prop1, p_points_array_bin, T_points_array_bin, x_points_bin, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)

            !this part is basically copied from the ptxdiag_out routine
            !former azeotropic mixture has split into two vle regions, the second one will be calculated next
            if (switchfluids == 2) then
                p_points_copy_bin = p_points_array_bin
                x_points_bin_copy = x_points_bin
                rhovap_points_copy_bin = rhovap_points
                rholiq_points_copy_bin = rholiq_points
                points_copy = points
                fluids_bin(1:2) = fluids_bin(2:1:-1)
                call setup (gl,input_bin, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)
                call pxdiag(gl,prop1, p_points_array_bin, T_points_array_bin, x_points_bin, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)
                p_points_copy_bin(points_copy+1) = -1.d0
                p_points_copy_bin(points_copy+2:points_copy+2+points) = p_points_array_bin(1:points)
                rhovap_points_copy_bin(points_copy+2:points_copy+2+points) = rhovap_points(1:points)
                rholiq_points_copy_bin(points_copy+2:points_copy+2+points) = rholiq_points(1:points)
                x_points_bin_copy(points_copy+2:points_copy+2+points, 1) = x_points_bin(1:points, 2)
                x_points_bin_copy(points_copy+2:points_copy+2+points, 2) = x_points_bin(1:points, 1)
                x_points_bin_copy(points_copy+2:points_copy+2+points, 3) = x_points_bin(1:points, 4)
                x_points_bin_copy(points_copy+2:points_copy+2+points, 4) = x_points_bin(1:points, 3)
                points = points + points_copy
                p_points_array_bin = p_points_copy_bin
                x_points_bin = x_points_bin_copy
                rhovap_points = rhovap_points_copy_bin
                rholiq_points = rholiq_points_copy_bin
                switchfluids = switchfluids_copy
            elseif (switchfluids == 3) then
                fluids_bin(1:2) = fluids_bin(2:1:-1)
                call setup (gl,input_bin, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)
                switchfluids = 1
                switchfluids_copy = switchfluids
                points = 1 
                call pxdiag(gl,prop1, p_points_array_bin, T_points_array_bin, x_points_bin, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)
            endif

            if (switchfluids > 0)then
                fluids_bin(1:2) = fluids_bin(2:1:-1)
                x_points_bin_copy = x_points_bin
                x_points_bin(:,1)=x_points_bin_copy(:,2)
                x_points_bin(:,2)=x_points_bin_copy(:,1)
                x_points_bin(:,3)=x_points_bin_copy(:,4)
                x_points_bin(:,4)=x_points_bin_copy(:,3)

            end if

            !set back to 0 because the pressue might be too low or high
            bin_test(i) = 0

            !search for the pressure on the phase boundaries to get an estimate for the compositions and flash for the exact pressure
            !no azeotrops yet
            if ((prop2 > p_points_array_bin(1)) .and. (errorflag==0)) then

                do j=1, size(p_points_array_bin,1)

                    if (prop2 < p_points_array_bin(j))then

                        moles_bin(1) = (x_points_bin(j,1) + x_points_bin(j,3))/2.0
                        moles_bin(2) = 1.d0 - moles_bin(1)

                        call setup (gl,input, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)
                        call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles_bin, rho, x_phase, phasetype, &
                            & phasefrac, nrofphases, nrsubst, errorflag)

                        if (nrofphases==1)then
                            moles_bin(1) = nint((x_points_bin(j,1) + x_points_bin(j,3))*1.d2/2.0)*1.d-2
                            moles_bin(2) = 1.d0 - moles_bin(1)

                            call setup (gl,input, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)
                            call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles_bin, rho, x_phase, phasetype, &
                                & phasefrac, nrofphases, nrsubst, errorflag)


                        end if
                        if (nrofphases > 1)then
                            moles_2ph(1,i) = x_phase(1,phasetype(1))
                            moles_2ph(2,i) = x_phase(1,phasetype(2))
                            bin_test(i) = 1
                            points_ter(i) = points_ter(i) + 1

                            !the binary 2 phase region is the first and starting point for the output matrix x_points
                            if (i==1) then

                                x_points(1,1 + 6*(i-1)) = moles_2ph(1,1)
                                x_points(1,2 + 6*(i-1)) = 1.d0 - moles_2ph(1,1)
                                x_points(1,3 + 6*(i-1)) = 0.d0

                                x_points(1,4 + 6*(i-1)) = moles_2ph(2,1)
                                x_points(1,5 + 6*(i-1)) = 1.d0 - moles_2ph(2,1)
                                x_points(1,6 + 6*(i-1)) = 0.d0

                            elseif (i==2) then

                                x_points(1,1 + 6*(i-1)) = moles_2ph(1,2)
                                x_points(1,3 + 6*(i-1)) = 1.d0 - moles_2ph(1,2)
                                x_points(1,2 + 6*(i-1)) = 0.d0

                                x_points(1,4 + 6*(i-1)) = moles_2ph(2,2)
                                x_points(1,6 + 6*(i-1)) = 1.d0 - moles_2ph(2,2)
                                x_points(1,5 + 6*(i-1)) = 0.d0

                            elseif (i==3) then

                                x_points(1,2 + 6*(i-1)) = moles_2ph(1,3)
                                x_points(1,3 + 6*(i-1)) = 1.d0 - moles_2ph(1,3)
                                x_points(1,1 + 6*(i-1)) = 0.d0

                                x_points(1,5 + 6*(i-1)) = moles_2ph(2,3)
                                x_points(1,6 + 6*(i-1)) = 1.d0 - moles_2ph(2,3)
                                x_points(1,4 + 6*(i-1)) = 0.d0

                            end if

                            rhovap_points_ter(1,1+(i-1)) = rho(phasetype(1))
                            rholiq_points_ter(1,1+(i-1)) = rho(phasetype(2))
                        end if
                        exit
                    end if

                end do

            end if

            !if px diagramm failed, test flash with 9 compositions between 0 and 1
            if (errorflag /=0)then

                do j=1, 9

                    moles_bin(1) = 0.1d0 * j
                    moles_bin(2) = 1.d0 - moles_bin(1)

                    call setup (gl,input, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)
                    call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles_bin, rho, x_phase, phasetype, &
                        & phasefrac, nrofphases, nrsubst, errorflag)


                    if (nrofphases > 1)then
                        moles_2ph(1,i) = x_phase(1,phasetype(1))
                        moles_2ph(2,i) = x_phase(1,phasetype(2))
                        bin_test(i) = 1
                        points_ter(i) = points_ter(i) + 1

                        !the binary 2 phase region is the first and starting point for the output matrix x_points
                        if (i==1) then

                            x_points(1,1 + 6*(i-1)) = moles_2ph(1,1)
                            x_points(1,2 + 6*(i-1)) = 1.d0 - moles_2ph(1,1)
                            x_points(1,3 + 6*(i-1)) = 0.d0

                            x_points(1,4 + 6*(i-1)) = moles_2ph(2,1)
                            x_points(1,5 + 6*(i-1)) = 1.d0 - moles_2ph(2,1)
                            x_points(1,6 + 6*(i-1)) = 0.d0

                        elseif (i==2) then

                            x_points(1,1 + 6*(i-1)) = moles_2ph(1,2)
                            x_points(1,3 + 6*(i-1)) = 1.d0 - moles_2ph(1,2)
                            x_points(1,2 + 6*(i-1)) = 0.d0

                            x_points(1,4 + 6*(i-1)) = moles_2ph(2,2)
                            x_points(1,6 + 6*(i-1)) = 1.d0 - moles_2ph(2,2)
                            x_points(1,5 + 6*(i-1)) = 0.d0

                        elseif (i==3) then

                            x_points(1,2 + 6*(i-1)) = moles_2ph(1,3)
                            x_points(1,3 + 6*(i-1)) = 1.d0 - moles_2ph(1,3)
                            x_points(1,1 + 6*(i-1)) = 0.d0

                            x_points(1,5 + 6*(i-1)) = moles_2ph(2,3)
                            x_points(1,6 + 6*(i-1)) = 1.d0 - moles_2ph(2,3)
                            x_points(1,4 + 6*(i-1)) = 0.d0

                        end if

                        rhovap_points_ter(1,1+(i-1)) = rho(phasetype(1))
                        rholiq_points_ter(1,1+(i-1)) = rho(phasetype(2))
                    end if
                    exit

                end do

            end if



            ! for open phase enevlopes and if p,x routine couldn't close the phase envelope because of failures in the calculation
            if (bin_test(i) == 0) then
                if (abs(x_points_bin(points,1)-x_points_bin(points,3)) > 0.001d0)then

                    moles_bin(1) = (x_points_bin(points,1) + x_points_bin(points,3))/2.0
                    moles_bin(2) = 1.d0 - moles_bin(1)

                    call setup (gl,input, prop1, prop2,fluids_bin, moles_bin, path, EOS_indicator_bin, MIX_indicator, errorflag)
                    call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles_bin, rho, x_phase, phasetype, &
                        & phasefrac, nrofphases, nrsubst, errorflag)

                    if (nrofphases>1)then
                        moles_2ph(1,i) = x_phase(1,phasetype(1))
                        moles_2ph(2,i) = x_phase(1,phasetype(2))
                        bin_test(i) = 1
                        points_ter(i) = points_ter(i) + 1

                        if (i==1) then

                            x_points(1,1 + 6*(i-1)) = moles_2ph(1,1)
                            x_points(1,2 + 6*(i-1)) = 1.d0 - moles_2ph(1,1)
                            x_points(1,3 + 6*(i-1)) = 0.d0

                            x_points(1,4 + 6*(i-1)) = moles_2ph(2,1)
                            x_points(1,5 + 6*(i-1)) = 1.d0 - moles_2ph(2,1)
                            x_points(1,6 + 6*(i-1)) = 0.d0

                        elseif (i==2) then

                            x_points(1,1 + 6*(i-1)) = moles_2ph(1,2)
                            x_points(1,3 + 6*(i-1)) = 1.d0 - moles_2ph(1,2)
                            x_points(1,2 + 6*(i-1)) = 0.d0

                            x_points(1,4 + 6*(i-1)) = moles_2ph(2,2)
                            x_points(1,6 + 6*(i-1)) = 1.d0 - moles_2ph(2,2)
                            x_points(1,5 + 6*(i-1)) = 0.d0

                        elseif (i==3) then

                            x_points(1,2 + 6*(i-1)) = moles_2ph(1,3)
                            x_points(1,3 + 6*(i-1)) = 1.d0 - moles_2ph(1,3)
                            x_points(1,1 + 6*(i-1)) = 0.d0

                            x_points(1,5 + 6*(i-1)) = moles_2ph(2,3)
                            x_points(1,6 + 6*(i-1)) = 1.d0 - moles_2ph(2,3)
                            x_points(1,4 + 6*(i-1)) = 0.d0

                        end if

                        rhovap_points_ter(1,1+(i-1)) = rho(phasetype(1))
                        rholiq_points_ter(1,1+(i-1)) = rho(phasetype(2))

                    end if



                end if


            end if



        end do

        if (sum(bin_test)==0) then
            errorflag=-4401 !Subroutine FLASH_PHASEBOUNDARY: MIX p,x(liq)-flash failed: no bubble point found
        end if


        ! calculate phase boundaries, starting from the binary, guess next point for flashing by using the middles between the two last dew and bubblepoints

        do i=1,3
            x_points_flash = 0.d0
            x_points_middle = 0.d0

            !check if there is a two phase region in binary and set first composition by adding 0.005mol to the third component for flashing
            if (i==1) then
                if (bin_test(1)==1) then

                    x_points_flash(1,1) = (moles_2ph(1,i) + moles_2ph(2,i))/2.d0
                    x_points_flash(1,2) = 1.d0 - x_points_flash(1,1) - 5.d-3
                    x_points_flash(1,3) = 1.d0 - x_points_flash(1,1) - x_points_flash(1,2)

                    x_points_middle(1,1) = x_points_flash(1,1)
                    x_points_middle(1,2) = 1.d0 - x_points_flash(1,1)
                    x_points_middle(1,3) = 0.d0

                else
                    cycle

                end if

            elseif (i==2) then

                if (bin_test(2)==1) then

                    x_points_flash(1,1) = (moles_2ph(1,i) + moles_2ph(2,i))/2.d0
                    x_points_flash(1,3) = 1.d0 - x_points_flash(1,1) - 5.d-3
                    x_points_flash(1,2) = 1.d0 - x_points_flash(1,1) - x_points_flash(1,3)

                    x_points_middle(1,1) = x_points_flash(1,1)
                    x_points_middle(1,3) = 1.d0 - x_points_flash(1,1)
                    x_points_middle(1,2) = 0.d0

                else
                    cycle

                end if

            elseif (i==3) then
                if (bin_test(3)==1) then

                    x_points_flash(1,2) = (moles_2ph(1,i) + moles_2ph(2,i))/2.d0
                    x_points_flash(1,3) = 1.d0 - x_points_flash(1,2) - 5.d-3
                    x_points_flash(1,1) = 1.d0 - x_points_flash(1,2) - x_points_flash(1,3)

                    x_points_middle(1,2) = x_points_flash(1,2)
                    x_points_middle(1,3) = 1.d0 - x_points_flash(1,2)
                    x_points_middle(1,1) = 0.d0

                else
                    cycle

                end if

            end if

            stepsize = 7.5d-3
            do j=1,maxi-2
                !initialize ternary
                if (j>1)then
                    !absolute value of distance between the two last middle points:
                    abs_middle = ((x_points_middle(j,1) - x_points_middle(j-1,1))**2 + (x_points_middle(j,2) - x_points_middle(j-1,2))**2 + (x_points_middle(j,3) - x_points_middle(j-1,3))**2)**0.5
                    x_points_flash(j,1) = (x_points_middle(j,1)) + stepsize * (x_points_middle(j,1) - x_points_middle(j-1,1)) / (abs_middle)
                    x_points_flash(j,2) = (x_points_middle(j,2)) + stepsize * (x_points_middle(j,2) - x_points_middle(j-1,2)) / (abs_middle)
                    x_points_flash(j,3) = 1.d0 -  x_points_flash(j,1) -  x_points_flash(j,2)

                    if ((x_points_flash(j,1)>1.d0) .and. (x_points_flash(j,1)<0.d0) .and. (x_points_flash(j,2)>1.d0) .and. (x_points_flash(j,2)<0.d0) .and. (x_points_flash(j,3)>1.d0) .and. (x_points_flash(j,3)<0.d0)) then
                        exit
                    end if
                end if

                moles(1) = x_points_flash(j,1)
                moles(2) = x_points_flash(j,2)
                moles(3) = x_points_flash(j,3)

                if (j==1)then
                    !new gl because changing from binary to ternary
                    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
                    if(errorflag /= 0) return
                end if

                call setup (gl,input, prop1, prop2,fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
                call inpt_handle (gl,input, prop1, prop2, p, t, d, dvap, dliq, moles, rho, x_phase, phasetype, &
                    & phasefrac, nrofphases, nrsubst, errorflag)

                if (errorflag ==0)then
                    if (nrofphases>1)then

                        errorflag_copy = 0

                        x_points(j+1,1 + 6*(i-1)) = x_phase(1,phasetype(1))
                        x_points(j+1,2 + 6*(i-1)) = x_phase(2,phasetype(1))
                        x_points(j+1,3 + 6*(i-1)) = 1.d0 - x_phase(1,phasetype(1)) - x_phase(2,phasetype(1))

                        x_points(j+1,4 + 6*(i-1)) = x_phase(1,phasetype(2))
                        x_points(j+1,5 + 6*(i-1)) = x_phase(2,phasetype(2))
                        x_points(j+1,6 + 6*(i-1)) = 1.d0 - x_phase(1,phasetype(2)) - x_phase(2,phasetype(2))

                        rhovap_points_ter(j+1,1+(i-1)) = rho(phasetype(1))
                        rholiq_points_ter(j+1,1+(i-1)) = rho(phasetype(2))

                        x_points_middle(j+1,1) = (x_phase(1,phasetype(2))+ x_phase(1,phasetype(1))) / 2.d0
                        x_points_middle(j+1,2) = (x_phase(2,phasetype(2))+ x_phase(2,phasetype(1))) / 2.d0
                        x_points_middle(j+1,3) = 1.d0 - x_points_middle(j+1,1) - x_points_middle(j+1,2)

                        points_ter(i) = points_ter(i) + 1
                    else
                        exit
                    end if
                else

                    exit

                end if

            end do

            !check if the ternary 2 phase region is close to one of the binary 2 phase region, then take binary 2 phase region point as last point in x_points and set bin_test of that binary to 0 so that the same points won't be calculated twice
            if (points_ter(i)>1)then
                do j=1,3
                    if (bin_test(j)  > 0)then
                        if((((x_points(points_ter(i),1 + 6*(i-1)) - x_points(1,1 + 6*(j-1)))**2 + ( x_points(points_ter(i),2 + 6*(i-1)) - x_points(1,2 + 6*(j-1)) )**2 + ( x_points(points_ter(i),3 + 6*(i-1)) - x_points(1,3 + 6*(j-1)) )**2 )**0.5) < stepsize) then

                            points_ter(i) = points_ter(i) + 1
                            bin_test(j)  = 0
                            errorflag_copy = 0

                            x_points(points_ter(i),1 + 6*(i-1)) =  x_points(1,1 + 6*(j-1))
                            x_points(points_ter(i),2 + 6*(i-1)) =  x_points(1,2 + 6*(j-1))
                            x_points(points_ter(i),3 + 6*(i-1)) =  x_points(1,3 + 6*(j-1))


                            x_points(points_ter(i),4 + 6*(i-1)) =  x_points(1,4 + 6*(j-1))
                            x_points(points_ter(i),5 + 6*(i-1)) =  x_points(1,5 + 6*(j-1))
                            x_points(points_ter(i),6 + 6*(i-1)) =  x_points(1,6 + 6*(j-1))


                            rhovap_points_ter(points_ter(i),1+(i-1)) = rhovap_points_ter(1,1+(j-1))
                            rholiq_points_ter(points_ter(i),1+(i-1)) = rholiq_points_ter(1,1+(j-1))

                        end if
                    end if
                end do
            end if


        end do

    end if

    !if two phase region was found, order the entries so that the vectors dont start with zeros
    if (maxval(points_ter)>0)then
        do i=1,2
            if (points_ter(i) == 0)then

                points_ter(i) = points_ter(i+1)
                points_ter(i+1) = 0.d0
                rhovap_points_ter(:,i) = rhovap_points_ter(:,i+1)
                rhovap_points_ter(:,i+1)  = 0.d0
                rholiq_points_ter(:,i) = rholiq_points_ter(:,i+1)
                rholiq_points_ter(:,i+1)  = 0.d0
                x_points(:,(6*i -5):(i*6)) = x_points(:,(i*6 + 1):((i+1)*6))
                x_points(:,(i*6 + 1):((i+1)*6)) = 0.d0


                if(i==1)then
                    points_ter(i+1) = points_ter(i+2)
                    points_ter(i+2) = 0.d0
                    rhovap_points_ter(:,i+1) = rhovap_points_ter(:,i+2)
                    rhovap_points_ter(:,i+2)  = 0.d0
                    rholiq_points_ter(:,i+1) = rholiq_points_ter(:,i+2)
                    rholiq_points_ter(:,i+2)  = 0.d0
                    x_points(:,(6*(i+1) -5):((i+1)*6)) = x_points(:,((i+1)*6 + 1):((i+2)*6))
                    x_points(:,((i+1)*6 + 1):((i+2)*6)) = 0.d0


                    if (points_ter(i) == 0)then
                        points_ter(i) = points_ter(i+1)
                        points_ter(i+1) = 0.d0
                        rhovap_points_ter(:,i) = rhovap_points_ter(:,i+1)
                        rhovap_points_ter(:,i+1)  = 0.d0
                        rholiq_points_ter(:,i) = rholiq_points_ter(:,i+1)
                        rholiq_points_ter(:,i+1)  = 0.d0
                        x_points(:,(6*i -5):(i*6)) = x_points(:,(i*6 + 1):((i+1)*6))
                        x_points(:,(i*6 + 1):((i+1)*6)) = 0.d0
                        exit
                    end if
                end if
            end if
        end do
    end if

    if (errorflag_copy == 0.d0)then
        errorflag = errorflag_copy
    endif


#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF


    end subroutine MAKE_FUNC_NAME(TERNARY_DIAG_OUT)



    subroutine MAKE_FUNC_NAME(PTXDIAG_ISOCH_OUT) (input_arg, prop, trace_var, fluids_arg, EOS_indicator, MIX_indicator, path_arg, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, &
        & points, fileout_arg, errorflag, gl_handle)
    !--------------------------------------------------------------------------------
    ! This subroutine is for interfacing the subroutine px_diag_isochoric (gl, Temp, p_points, T_points, x_points, rhovap_points, rholiq_points, points, fileout, errorflag)
    ! Bell, I.H.; Deiters U.K.: "On the Construction of Binary Mixture p-x and T-x Diagrams from Isochoric Thermodynamics", AIChe Journal 64(7), 2745-2757, 2018.
    !--------------------------------------------------------------------------------
    ! Andreas Jäger, November 2018
    !##########################################################################################
#define LOCAL_FUNC_NAME() PTXDIAG_ISOCH_OUT
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

    MAKE_ARG_CHAR(12), intent(in) :: input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) :: path_arg
    MAKE_ARG_CHAR(255), intent(in) :: fileout_arg



    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    !--------------------------------------------------------------------------------
    integer, intent(out):: points, errorflag                ! number of calculated points, error code
    integer :: trace_var                                !Variable to indicate which molar concentration is used for tracing (1 = rho
    integer :: points_copy, errorflag_copy
    integer, parameter:: maxi = 1001 ! maximum number of calculated points, length of the return vectors!
    double precision:: prop     ! specified temperature for the p-x diagram
    double precision, dimension(maxi) :: T_points_array, p_points_array, rhovap_points, rholiq_points    ! return vectors of the calculated points
    double precision :: x_points(maxi,2)   ! this array is filled according to:
    ! x_points(i,1) = x_vap(1), x_points(i,2) = x_liq(1)
    double precision, dimension(30):: moles              ! composition of the system

    character(12) :: input
    character(255) :: fileout    ! optional path for output file

    character (30), dimension(30) :: fluids
    integer, dimension(30) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin ! dummy variable for control_fluids
    character (255) :: path
    integer :: i,j
    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(input, 12)
    STRING_TO_F(path, 255)
    STRING_TO_F(fileout,255)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if(errorflag /= 0) return

    call uppertolower_char(input,12 )
    moles = 0.d0
    moles(1:2) = 0.5d0

    errorflag = 0
    !delete semicolon at the end of the string

    !if (fluids(len(trim(fluids)):len(trim(fluids))) == ";")  fluids = fluids(1:len(trim(fluids))-1)

    if ((trim(input) == 'tvap').or.(trim(input) == 'tliq')) then
        call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
        !catch very low temperatures
        if (prop < 0.5d0*minval(gl%tminfluid(1:2)) )then
            errorflag = -5531
            return
        endif
        if (errorflag == 0) then
            !check if given temperature is above both critical temperatures, if yes, quit with error
            if ((prop > gl%tc(1)).and.(prop > gl%tc(2))) then
                errorflag = -5530
                return
            endif

            call px_diag_isochoric (gl, prop, trace_var, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, errorflag)

        else
            return
        endif

    elseif ((trim(input) == 'pvap').or.(trim(input) == 'pliq')) then
        errorflag = -9955
    else
        errorflag = -9955
    endif

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(PTXDIAG_ISOCH_OUT)


    !-------------------------------------------------
    !Function for save_phasedetbounds
    !This function is used to save the previous results of a phase detection and reuse them
    !as boundaries for the p_min p_max values in the regula falsi routine in case
    !the next calculation fails.
    !toggle values:  0 - ask current status
    !                1 - enable save toggle
    !               -1 - disable save toggle
    !return values:  0 - save toggle is disabled
    !                1 - save toggle is enabled
    !-------------------------------------------------
    integer function MAKE_FUNC_NAME(SAVE_PHASEDETBOUNDS) (toggle, gl_handle) result(SAVE_PHASEDETBOUNDS_RESULT)
    !##########################################################################################
#define LOCAL_FUNC_NAME() SAVE_PHASEDETBOUNDS
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle


    integer, intent(in) :: toggle

    if(.not. c_associated(gl_handle)) then !create a new fluid and save the gl_handle
        SAVE_PHASEDETBOUNDS_RESULT = 0
    else
        CALL C_F_POINTER(gl_handle,gl)

        if (toggle == 0) then
            if (gl%savebounds_p .eqv. .true.) then
                SAVE_PHASEDETBOUNDS_RESULT = 1
            elseif (gl%savebounds_p .eqv. .false.) then
                SAVE_PHASEDETBOUNDS_RESULT = 0
            end if
        elseif (toggle == 1) then
            gl%savebounds_p = .true.
            SAVE_PHASEDETBOUNDS_RESULT = 1
        elseif (toggle == -1) then
            gl%savebounds_p = .false.
            SAVE_PHASEDETBOUNDS_RESULT = 0
        end if
    end if

    end function MAKE_FUNC_NAME(SAVE_PHASEDETBOUNDS)


    subroutine MAKE_FUNC_NAME(TREND_CALC) (T,D,nrsubst,prop_list,results,prop_name,errorflag,gl_handle_arr)
    !##########################################################################################
#define LOCAL_FUNC_NAME() TREND_CALC
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none
    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(c_ptr), intent(inout) :: gl_handle_arr
    !-------------------------------------------------------------------------
    !input variables
    integer, intent(in):: nrsubst
    integer, dimension(100), intent(in) :: prop_list
    double precision, dimension(100):: results

    character(30), dimension(100), intent(out) :: prop_name
    double precision, intent(in) :: T,D
    integer :: errorflag
    ! CALL OF INTERFACE FUNCTION

    call TREND_CALC_INTERFACE(T,D,nrsubst,prop_list,results,prop_name,errorflag,gl_handle_arr)

    end subroutine MAKE_FUNC_NAME(TREND_CALC)
    !##########################################################################################



    subroutine MAKE_FUNC_NAME(CONTROL_FLUID_handle) (input_arg,fluids_arg, moles, EOS_indicator, MIX_indicator, path_arg, unitdefinition_arg,errorflag, gl_handle_control, gl_handle_arr)
    !##########################################################################################
#define LOCAL_FUNC_NAME() CONTROL_FLUID_handle
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none
    MAKE_ARG_CHAR(12), intent(in) :: input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg

    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle_arr

    !Define input variables
    character (12) :: input,unit
    character (30), dimension(30) :: fluids
    double precision, dimension (30) :: moles
    character (255) :: path
    integer, dimension (30) :: EOS_indicator
    integer :: MIX_indicator
    integer :: errorflag
    character (20) :: unitdefinition
    integer, intent(inout):: gl_handle_control
    !-------------------------------------------------------------------------------------------------------------------------------------------------

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo

#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(input, 12)
    STRING_TO_F(path, 255)
    STRING_TO_F(unitdefinition,20)

    !Preprocessor definition end
    !##########################################################################################


    ! CALL OF INTERFACE FUNCTION

    call CONTROL_FLUID_handle_INTERFACE (gl,input,fluids, moles, EOS_indicator, MIX_indicator, path, unitdefinition,errorflag, gl_handle_control, gl_handle_arr)

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(CONTROL_FLUID_handle)
    !##########################################################################################



    ! DESTROY_FLUID_handle destroys a previously allocated gl_type which gl_handle referes to
    subroutine MAKE_FUNC_NAME(DESTROY_FLUID_handle) (gl_handle)
    !##########################################################################################
#define LOCAL_FUNC_NAME() DESTROY_FLUID_handle
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    implicit none

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    ! check if gl_handle is associated with a gl_type
    if(c_associated(gl_handle)) then
        ! destroy it
        call DESTROY_FLUID (gl_handle)
    endif

    end subroutine MAKE_FUNC_NAME(DESTROY_FLUID_handle)

#IF DEFINED(IDEAL_CURVES) 
    subroutine MAKE_FUNC_NAME(TREND_IDEAL_CURVE) (fluids_arg, EOS_indicator, MIX_indicator, path_arg,unitdefinition_arg, errorflag, gl_handle,plt_in)
    !##########################################################################################
#define LOCAL_FUNC_NAME() TREND_IDEAL_CURVE
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################
    !use module_fluid_parameters
    use, intrinsic :: iso_c_binding
    use module_all_types
    use controlling
    use ideal_curves

#IF DEFINED (MAKE_SAFEARR)
    use ifcom
    use safearrays
#ENDIF


    implicit none


#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) ::  path_arg
    MAKE_ARG_CHAR(20), intent(in) ::  unitdefinition_arg

    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------

    !Define input variables
    character (12) :: input
    character(12) :: calctype
    character (30), dimension(30) :: fluids
    double precision, dimension (30) :: moles
    character (255) :: path
    integer, dimension (30) :: EOS_indicator
    character (20) :: unitdefinition
    integer :: MIX_indicator

    !create new class ideal
    type(ideal):: id
    integer:: errorflag, i
    double precision :: res
    integer:: nrsubst
    type(plot_i):: plt_in

    !-------------------------------------------------------------------------------------------------------------------------------------------------

    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(path, 255)
    STRING_TO_F(unitdefinition,20)

    !Preprocessor definition end
    !##########################################################################################

    plt_i = plt_in
    input = 'TP'
    moles = 0d0
    moles(1) = 1d0
    nrsubst = 1
    id = ideal(gl,input,fluids,moles,EOS_indicator,path,unitdefinition,gl_handle,nrsubst)

    call id%get_classic(gl,1)

    end subroutine MAKE_FUNC_NAME(TREND_IDEAL_CURVE)
#ENDIF






    subroutine MAKE_FUNC_NAME(PTXDIAG_OUT_MONI) (input_arg, prop, fluids_arg, EOS_indicator, MIX_indicator, path_arg, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, &
        & points, fileout_arg, errorflag, gl_handle)
    !--------------------------------------------------------------------------------
    !    This subroutine is for interfacing px_moni for dlls calls
    !--------------------------------------------------------------------------------
    ! M. Thol, May 2019
    !##########################################################################################
#define LOCAL_FUNC_NAME() PTXDIAG_OUT_MONI
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################

    use, intrinsic :: iso_c_binding
    use module_all_types
    use controlling
#IF DEFINED (MAKE_SAFEARR)
    use ifcom
    use safearrays
#ENDIF

    implicit none

    MAKE_ARG_CHAR(12), intent(in) :: input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) :: path_arg
    MAKE_ARG_CHAR(255), intent(in) :: fileout_arg



    !-------------------------------------------------------------------------
    !gl_handle for gl
    type(type_gl), pointer:: gl
    type(c_ptr), intent(inout):: gl_handle
    !-------------------------------------------------------------------------


    !--------------------------------------------------------------------------------
    integer, intent(out):: points, errorflag                ! number of calculated points, error code
    integer :: points_copy, errorflag_copy
    integer, parameter:: maxi = 2000 ! maximum number of calculated points, lengt of the return vectors!
    double precision:: prop     ! specified temperature for the p-x diagram
    double precision, dimension(maxi), intent(out):: T_points_array, p_points_array, rhovap_points, rholiq_points    ! return vectors of the calculated points
    double precision, intent(out):: x_points(maxi,4)   ! this array is filled according to:
    ! x_points(i,1) = x_vap(1), x_points(i,2) = x_vap(2)
    ! x_points(i,3) = x_liq(1), x_points(i,4) = x_liq(2)
    double precision, dimension(maxi):: T_points_copy, p_points_copy, rhovap_points_copy, rholiq_points_copy    ! return vectors of the calculated points
    double precision :: x_points_copy(maxi,4)   ! this array is filled according to:
    ! x_points(i,1) = x_vap(1), x_points(i,2) = x_vap(2)
    ! x_points(i,3) = x_liq(1), x_points(i,4) = x_liq(2)
    double precision, dimension(30):: moles              ! composition of the system

    character(12) :: input
    character(255) :: fileout    ! optional path for output file

    character (30), dimension(30) :: fluids
    integer, dimension(30) :: EOS_indicator
    integer :: MIX_indicator
    integer :: unitin ! dummy variable for control_fluids
    character (255) :: path
    !switchfluids = 1: fluid order was switched -> this has to be undone by swapping point order and molefractions x1 -> x2, x2 -> x1
    !switchfluids = 2: former azeotropic mixture, splited in two vle regions (co2-ethane T > 290 K)
    !swtichfluids = 3: Mostly relevant for open VLE regions -> start with component with smaller vapor pressure or higher saturation temperature,
    !                  because this component will most likely be attached to y axis while the other component is detached from y axis
    integer :: i,j, switchfluids, switchfluids_copy
    !##########################################################################################
    !Preprocessor definition start

#IF DEFINED (MAKE_MATLAB)
    do i = 1,size(fluids,1)
        STRING_ARRAY_TO_F(fluids, 30)
    enddo
#ELIF DEFINED(MAKE_SAFEARR)
    allocate(fluids_allo(30))
    fluids_allo = fluids
    call safearray_to_chararray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    fluids = fluids_allo
#ELSE
    STRING_TO_F(fluids, 30)
#ENDIF
    STRING_TO_F(input, 12)
    STRING_TO_F(path, 255)
    STRING_TO_F(fileout,255)

    !Preprocessor definition end
    !##########################################################################################

    unitin = 1

    !control gl_handle and fluid input fot memory usage
    call control_fluids(gl,input,fluids,moles,EOS_indicator,unitin,gl_handle,errorflag)
    if(errorflag /= 0) return

    call uppertolower_char(input,12 )
    moles = 0.d0
    moles(1:2) = 0.5d0

    errorflag = 0
    switchfluids = 0 !fluid order was not changed
    switchfluids_copy = 0

    if ((trim(input) == 'tvap').or.(trim(input) == 'tliq')) then
        call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
        !catch very low temperatures
        if ((prop < gl%ttp(1)).and.(prop < gl%ttp(2))) then
            errorflag = -5531
            return
        endif
        if (errorflag == 0) then
            !check if given temperature is below both critical temperatures
            if ((prop > gl%tc(1)).and.(prop > gl%tc(2))) then
                errorflag = -5530
                return
                !check if given temperature is below critical temperature of first fluid
                !if input temperature is above tc(1) switch the fluid order, because the calculation starts always with x(1) = 1 side
                !this has to be undone after the calculations are finished
            elseif (prop > gl%tc(1)) then
                fluids(1:2) = fluids(2:1:-1)
                call setup (gl,input, prop, prop, fluids, moles, path, EOS_indicator, MIX_indicator, errorflag)
                switchfluids = 1
                switchfluids_copy = switchfluids
            endif
            call px_moni(gl,prop, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, points, fileout, switchfluids, errorflag)
        endif
    end if

#IF DEFINED(MAKE_SAFEARR)
    fluids_allo = fluids
    call chararray_to_safearray(fluids_arg,30, FORTRAN_char_vektor=fluids_allo)
    deallocate(fluids_allo)
#ENDIF

    end subroutine MAKE_FUNC_NAME(PTXDIAG_OUT_MONI)



    ! Sven Pohl
    !parallel version of ptxdiag_out
    !
    subroutine MAKE_FUNC_NAME(PTXDIAG_OUT_P) (input_arg, prop, fluids_arg, EOS_indicator, MIX_indicator, path_arg, p_points_array, T_points_array, x_points, rhovap_points, rholiq_points, &
        & points, fileout_arg, errorflag ,nr_cores)

    !--------------------------------------------------------------------------------
    !    This subroutine is for interfacing pxdiag and txdiag routines for dlls calls
    !--------------------------------------------------------------------------------
    ! S.Hielscher und S.Herrig, June 2016, revised Nov 2016
    !##########################################################################################
#define LOCAL_FUNC_NAME() PTXDIAG_OUT_P
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################
#IF(PTX_PARALLEL)
    use omp_lib

    implicit none

    MAKE_ARG_CHAR(12), intent(in) :: input_arg
#IF DEFINED (MAKE_SAFEARR)
    integer(int_ptr_kind()), intent(inout) :: fluids_arg
    character(30), dimension(:), allocatable :: fluids_allo
#ELSE
    MAKE_ARG_CHAR_ARRAY(30, 30), intent(in) ::  fluids_arg
#ENDIF
    MAKE_ARG_CHAR(255), intent(in) :: path_arg
    MAKE_ARG_CHAR(255), intent(in) :: fileout_arg
    integer, dimension(30) :: EOS_indicator
    integer :: MIX_indicator
    integer, intent(in):: nr_cores
    integer, intent(out), dimension(nr_cores) :: points
    integer, intent(out) :: errorflag                ! number of calculated points, error code
    integer, parameter:: maxi = 300 ! maximum number of calculated points, lengt of the return vectors!
    double precision, dimension(nr_cores) :: prop     ! temperature array
    double precision, dimension(maxi,nr_cores), intent(out):: T_points_array, p_points_array, rhovap_points, rholiq_points    ! return vectors of the calculated points
    double precision, intent(out), dimension(maxi,4,nr_cores):: x_points
    double precision, dimension(30):: moles              ! composition of the system
    type(c_ptr), dimension(nr_cores):: handle_arr
    character(255), dimension(nr_cores) :: path_arr
    integer, dimension(nr_cores) :: errorflag_arr

    !parallel stuff
    integer:: nr_available_cores
    integer:: loop_t
    !check available cores

    !nr_available_cores = OMP_GET_NUM_PROCS()
    !if(nr_available_cores .gt. nr_cores) then
    !    call omp_set_num_threads(nr_cores)
    !else
    !    call omp_set_num_threads(nr_available_cores)
    !end if

    handle_arr = c_null_ptr
    errorflag_arr = 0
    path_arr = path_arg

    !!$omp parallel do
    do loop_t = 1,nr_cores
        if(prop(loop_t) .ne. 0d0) then
            call PTXDIAG_OUT(input_arg, prop(loop_t), fluids_arg, EOS_indicator, MIX_indicator, path_arr(loop_t), p_points_array(:,loop_t), T_points_array(:,loop_t), x_points(:,:,loop_t), rhovap_points(:,loop_t), rholiq_points(:,loop_t), &
                & points(loop_t), fileout_arg, errorflag_arr(loop_t),handle_arr(loop_t))
        end if
    end do
    !!$omp end parallel do

#ELSE
    write(*,*) 'not available in this version'
#ENDIF
    end subroutine MAKE_FUNC_NAME(PTXDIAG_OUT_P)



    !      Interface funtion for FLASH PURE FLUID

    subroutine MAKE_FUNC_NAME(FLASH_PURE_DLL)(fld_in, press, Temp, rhovap_est, rholiq_est, iFlash, errval, iter, nrsubst, n_call)
    !##########################################################################################
#define LOCAL_FUNC_NAME() FLASH_PURE_DLL
#include "dllexport_attributes.fi"
#undef LOCAL_FUNC_NAME
    !##########################################################################################
    use fluid
    type(fld) :: fld_in
    type(type_gl), pointer:: gl
    double precision :: press
    double precision :: Temp
    double precision :: rhovap_est, rholiq_est
    integer :: iFlash, n_call
    integer :: errval, iter
    integer :: nrsubst
    integer:: errorflag

    call control_fluids(gl,fld_in%input,fld_in%fluids,fld_in%moles,fld_in%EOS_ind,fld_in%unitin,fld_in%handle,errorflag)

    if(errorflag == 0) then
        call Flash_Pure_PhaseBoundary_calc (gl,press, Temp, rhovap_est, rholiq_est, iFlash, errval, iter, nrsubst, n_call)
    else
        rhovap_est = errorflag
        rholiq_est = errorflag
    end if

    end subroutine MAKE_FUNC_NAME(FLASH_PURE_DLL)



    end module MAKE_MODULE_NAME(interface_routines)

